Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> subprogram
Rule 2     subprogram -> statement
Rule 3     subprogram -> statement ; subprogram
Rule 4     statement -> assignation
Rule 5     statement -> structure
Rule 6     statement -> shape
Rule 7     statement -> animation
Rule 8     statement -> PRINT expression
Rule 9     structure -> WHILE expression { subprogram }
Rule 10    animation -> translation
Rule 11    translation -> TRANSLATE ( IDENTIFIER , point_expression )
Rule 12    translation -> ROTATE ( IDENTIFIER , expression )
Rule 13    shape -> circle_g
Rule 14    shape -> rect_g
Rule 15    circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
Rule 16    rect_g -> RECT { point_expression , size_expression , color_expression }
Rule 17    point_expression -> POINT ( expression , expression )
Rule 18    size_expression -> SIZE ( expression , expression )
Rule 19    color_expression -> COLOR ( expression , expression , expression )
Rule 20    expression -> expression ADD_OP expression
Rule 21    expression -> expression MUL_OP expression
Rule 22    expression -> NUMBER
Rule 23    expression -> IDENTIFIER
Rule 24    expression -> ( expression )
Rule 25    expression -> ADD_OP expression
Rule 26    assignation -> IDENTIFIER = assign_expression
Rule 27    assign_expression -> expression
Rule 28    assign_expression -> shape

Terminals, with rules where they appear

(                    : 11 12 15 17 18 19 24
)                    : 11 12 15 17 18 19 24
,                    : 11 12 15 15 16 16 17 18 19 19
;                    : 3
=                    : 26
ADD_OP               : 20 25
CIRCLE               : 15
COLOR                : 19
IDENTIFIER           : 11 12 23 26
MUL_OP               : 21
NUMBER               : 22
POINT                : 17
PRINT                : 8
RADIUS               : 15
RECT                 : 16
ROTATE               : 12
SIZE                 : 18
TRANSLATE            : 11
WHILE                : 9
error                : 
{                    : 9 15 16
}                    : 9 15 16

Nonterminals, with rules where they appear

animation            : 7
assign_expression    : 26
assignation          : 4
circle_g             : 13
color_expression     : 15 16
expression           : 8 9 12 15 17 17 18 18 19 19 19 20 20 21 21 24 25 27
point_expression     : 11 15 16
program              : 0
rect_g               : 14
shape                : 6 28
size_expression      : 16
statement            : 2 3
structure            : 5
subprogram           : 1 3 9
translation          : 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . subprogram
    (2) subprogram -> . statement
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . shape
    (7) statement -> . animation
    (8) statement -> . PRINT expression
    (26) assignation -> . IDENTIFIER = assign_expression
    (9) structure -> . WHILE expression { subprogram }
    (13) shape -> . circle_g
    (14) shape -> . rect_g
    (10) animation -> . translation
    (15) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (16) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (11) translation -> . TRANSLATE ( IDENTIFIER , point_expression )
    (12) translation -> . ROTATE ( IDENTIFIER , expression )

    PRINT           shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    CIRCLE          shift and go to state 14
    RECT            shift and go to state 15
    TRANSLATE       shift and go to state 16
    ROTATE          shift and go to state 17

    program                        shift and go to state 1
    subprogram                     shift and go to state 2
    statement                      shift and go to state 3
    assignation                    shift and go to state 4
    structure                      shift and go to state 5
    shape                          shift and go to state 6
    animation                      shift and go to state 7
    circle_g                       shift and go to state 11
    rect_g                         shift and go to state 12
    translation                    shift and go to state 13

state 1

    (0) S' -> program .



state 2

    (1) program -> subprogram .

    $end            reduce using rule 1 (program -> subprogram .)


state 3

    (2) subprogram -> statement .
    (3) subprogram -> statement . ; subprogram

    $end            reduce using rule 2 (subprogram -> statement .)
    }               reduce using rule 2 (subprogram -> statement .)
    ;               shift and go to state 18


state 4

    (4) statement -> assignation .

    ;               reduce using rule 4 (statement -> assignation .)
    $end            reduce using rule 4 (statement -> assignation .)
    }               reduce using rule 4 (statement -> assignation .)


state 5

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)
    $end            reduce using rule 5 (statement -> structure .)
    }               reduce using rule 5 (statement -> structure .)


state 6

    (6) statement -> shape .

    ;               reduce using rule 6 (statement -> shape .)
    $end            reduce using rule 6 (statement -> shape .)
    }               reduce using rule 6 (statement -> shape .)


state 7

    (7) statement -> animation .

    ;               reduce using rule 7 (statement -> animation .)
    $end            reduce using rule 7 (statement -> animation .)
    }               reduce using rule 7 (statement -> animation .)


state 8

    (8) statement -> PRINT . expression
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 19

state 9

    (26) assignation -> IDENTIFIER . = assign_expression

    =               shift and go to state 24


state 10

    (9) structure -> WHILE . expression { subprogram }
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 25

state 11

    (13) shape -> circle_g .

    ;               reduce using rule 13 (shape -> circle_g .)
    $end            reduce using rule 13 (shape -> circle_g .)
    }               reduce using rule 13 (shape -> circle_g .)


state 12

    (14) shape -> rect_g .

    ;               reduce using rule 14 (shape -> rect_g .)
    $end            reduce using rule 14 (shape -> rect_g .)
    }               reduce using rule 14 (shape -> rect_g .)


state 13

    (10) animation -> translation .

    ;               reduce using rule 10 (animation -> translation .)
    $end            reduce using rule 10 (animation -> translation .)
    }               reduce using rule 10 (animation -> translation .)


state 14

    (15) circle_g -> CIRCLE . { point_expression , RADIUS ( expression ) , color_expression }

    {               shift and go to state 26


state 15

    (16) rect_g -> RECT . { point_expression , size_expression , color_expression }

    {               shift and go to state 27


state 16

    (11) translation -> TRANSLATE . ( IDENTIFIER , point_expression )

    (               shift and go to state 28


state 17

    (12) translation -> ROTATE . ( IDENTIFIER , expression )

    (               shift and go to state 29


state 18

    (3) subprogram -> statement ; . subprogram
    (2) subprogram -> . statement
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . shape
    (7) statement -> . animation
    (8) statement -> . PRINT expression
    (26) assignation -> . IDENTIFIER = assign_expression
    (9) structure -> . WHILE expression { subprogram }
    (13) shape -> . circle_g
    (14) shape -> . rect_g
    (10) animation -> . translation
    (15) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (16) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (11) translation -> . TRANSLATE ( IDENTIFIER , point_expression )
    (12) translation -> . ROTATE ( IDENTIFIER , expression )

    PRINT           shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    CIRCLE          shift and go to state 14
    RECT            shift and go to state 15
    TRANSLATE       shift and go to state 16
    ROTATE          shift and go to state 17

    statement                      shift and go to state 3
    subprogram                     shift and go to state 30
    assignation                    shift and go to state 4
    structure                      shift and go to state 5
    shape                          shift and go to state 6
    animation                      shift and go to state 7
    circle_g                       shift and go to state 11
    rect_g                         shift and go to state 12
    translation                    shift and go to state 13

state 19

    (8) statement -> PRINT expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    ;               reduce using rule 8 (statement -> PRINT expression .)
    $end            reduce using rule 8 (statement -> PRINT expression .)
    }               reduce using rule 8 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 20

    (25) expression -> ADD_OP . expression
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 33

state 21

    (22) expression -> NUMBER .

    ADD_OP          reduce using rule 22 (expression -> NUMBER .)
    MUL_OP          reduce using rule 22 (expression -> NUMBER .)
    ;               reduce using rule 22 (expression -> NUMBER .)
    $end            reduce using rule 22 (expression -> NUMBER .)
    }               reduce using rule 22 (expression -> NUMBER .)
    {               reduce using rule 22 (expression -> NUMBER .)
    )               reduce using rule 22 (expression -> NUMBER .)
    ,               reduce using rule 22 (expression -> NUMBER .)


state 22

    (23) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 23 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 23 (expression -> IDENTIFIER .)
    ;               reduce using rule 23 (expression -> IDENTIFIER .)
    $end            reduce using rule 23 (expression -> IDENTIFIER .)
    }               reduce using rule 23 (expression -> IDENTIFIER .)
    {               reduce using rule 23 (expression -> IDENTIFIER .)
    )               reduce using rule 23 (expression -> IDENTIFIER .)
    ,               reduce using rule 23 (expression -> IDENTIFIER .)


state 23

    (24) expression -> ( . expression )
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 34

state 24

    (26) assignation -> IDENTIFIER = . assign_expression
    (27) assign_expression -> . expression
    (28) assign_expression -> . shape
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression
    (13) shape -> . circle_g
    (14) shape -> . rect_g
    (15) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (16) rect_g -> . RECT { point_expression , size_expression , color_expression }

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20
    CIRCLE          shift and go to state 14
    RECT            shift and go to state 15

    assign_expression              shift and go to state 35
    expression                     shift and go to state 36
    shape                          shift and go to state 37
    circle_g                       shift and go to state 11
    rect_g                         shift and go to state 12

state 25

    (9) structure -> WHILE expression . { subprogram }
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    {               shift and go to state 38
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 26

    (15) circle_g -> CIRCLE { . point_expression , RADIUS ( expression ) , color_expression }
    (17) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 40

    point_expression               shift and go to state 39

state 27

    (16) rect_g -> RECT { . point_expression , size_expression , color_expression }
    (17) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 40

    point_expression               shift and go to state 41

state 28

    (11) translation -> TRANSLATE ( . IDENTIFIER , point_expression )

    IDENTIFIER      shift and go to state 42


state 29

    (12) translation -> ROTATE ( . IDENTIFIER , expression )

    IDENTIFIER      shift and go to state 43


state 30

    (3) subprogram -> statement ; subprogram .

    $end            reduce using rule 3 (subprogram -> statement ; subprogram .)
    }               reduce using rule 3 (subprogram -> statement ; subprogram .)


state 31

    (20) expression -> expression ADD_OP . expression
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 44

state 32

    (21) expression -> expression MUL_OP . expression
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 45

state 33

    (25) expression -> ADD_OP expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 25 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 25 (expression -> ADD_OP expression .)
    ;               reduce using rule 25 (expression -> ADD_OP expression .)
    $end            reduce using rule 25 (expression -> ADD_OP expression .)
    }               reduce using rule 25 (expression -> ADD_OP expression .)
    {               reduce using rule 25 (expression -> ADD_OP expression .)
    )               reduce using rule 25 (expression -> ADD_OP expression .)
    ,               reduce using rule 25 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 31 ]
  ! MUL_OP          [ shift and go to state 32 ]


state 34

    (24) expression -> ( expression . )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    )               shift and go to state 46
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 35

    (26) assignation -> IDENTIFIER = assign_expression .

    ;               reduce using rule 26 (assignation -> IDENTIFIER = assign_expression .)
    $end            reduce using rule 26 (assignation -> IDENTIFIER = assign_expression .)
    }               reduce using rule 26 (assignation -> IDENTIFIER = assign_expression .)


state 36

    (27) assign_expression -> expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    ;               reduce using rule 27 (assign_expression -> expression .)
    $end            reduce using rule 27 (assign_expression -> expression .)
    }               reduce using rule 27 (assign_expression -> expression .)
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 37

    (28) assign_expression -> shape .

    ;               reduce using rule 28 (assign_expression -> shape .)
    $end            reduce using rule 28 (assign_expression -> shape .)
    }               reduce using rule 28 (assign_expression -> shape .)


state 38

    (9) structure -> WHILE expression { . subprogram }
    (2) subprogram -> . statement
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . shape
    (7) statement -> . animation
    (8) statement -> . PRINT expression
    (26) assignation -> . IDENTIFIER = assign_expression
    (9) structure -> . WHILE expression { subprogram }
    (13) shape -> . circle_g
    (14) shape -> . rect_g
    (10) animation -> . translation
    (15) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (16) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (11) translation -> . TRANSLATE ( IDENTIFIER , point_expression )
    (12) translation -> . ROTATE ( IDENTIFIER , expression )

    PRINT           shift and go to state 8
    IDENTIFIER      shift and go to state 9
    WHILE           shift and go to state 10
    CIRCLE          shift and go to state 14
    RECT            shift and go to state 15
    TRANSLATE       shift and go to state 16
    ROTATE          shift and go to state 17

    subprogram                     shift and go to state 47
    statement                      shift and go to state 3
    assignation                    shift and go to state 4
    structure                      shift and go to state 5
    shape                          shift and go to state 6
    animation                      shift and go to state 7
    circle_g                       shift and go to state 11
    rect_g                         shift and go to state 12
    translation                    shift and go to state 13

state 39

    (15) circle_g -> CIRCLE { point_expression . , RADIUS ( expression ) , color_expression }

    ,               shift and go to state 48


state 40

    (17) point_expression -> POINT . ( expression , expression )

    (               shift and go to state 49


state 41

    (16) rect_g -> RECT { point_expression . , size_expression , color_expression }

    ,               shift and go to state 50


state 42

    (11) translation -> TRANSLATE ( IDENTIFIER . , point_expression )

    ,               shift and go to state 51


state 43

    (12) translation -> ROTATE ( IDENTIFIER . , expression )

    ,               shift and go to state 52


state 44

    (20) expression -> expression ADD_OP expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 20 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 20 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 20 (expression -> expression ADD_OP expression .)
    }               reduce using rule 20 (expression -> expression ADD_OP expression .)
    {               reduce using rule 20 (expression -> expression ADD_OP expression .)
    )               reduce using rule 20 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 20 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 32

  ! MUL_OP          [ reduce using rule 20 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 31 ]


state 45

    (21) expression -> expression MUL_OP expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 21 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 21 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 21 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 21 (expression -> expression MUL_OP expression .)
    }               reduce using rule 21 (expression -> expression MUL_OP expression .)
    {               reduce using rule 21 (expression -> expression MUL_OP expression .)
    )               reduce using rule 21 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 21 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 31 ]
  ! MUL_OP          [ shift and go to state 32 ]


state 46

    (24) expression -> ( expression ) .

    ADD_OP          reduce using rule 24 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 24 (expression -> ( expression ) .)
    ;               reduce using rule 24 (expression -> ( expression ) .)
    $end            reduce using rule 24 (expression -> ( expression ) .)
    }               reduce using rule 24 (expression -> ( expression ) .)
    {               reduce using rule 24 (expression -> ( expression ) .)
    )               reduce using rule 24 (expression -> ( expression ) .)
    ,               reduce using rule 24 (expression -> ( expression ) .)


state 47

    (9) structure -> WHILE expression { subprogram . }

    }               shift and go to state 53


state 48

    (15) circle_g -> CIRCLE { point_expression , . RADIUS ( expression ) , color_expression }

    RADIUS          shift and go to state 54


state 49

    (17) point_expression -> POINT ( . expression , expression )
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 55

state 50

    (16) rect_g -> RECT { point_expression , . size_expression , color_expression }
    (18) size_expression -> . SIZE ( expression , expression )

    SIZE            shift and go to state 57

    size_expression                shift and go to state 56

state 51

    (11) translation -> TRANSLATE ( IDENTIFIER , . point_expression )
    (17) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 40

    point_expression               shift and go to state 58

state 52

    (12) translation -> ROTATE ( IDENTIFIER , . expression )
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 59

state 53

    (9) structure -> WHILE expression { subprogram } .

    ;               reduce using rule 9 (structure -> WHILE expression { subprogram } .)
    $end            reduce using rule 9 (structure -> WHILE expression { subprogram } .)
    }               reduce using rule 9 (structure -> WHILE expression { subprogram } .)


state 54

    (15) circle_g -> CIRCLE { point_expression , RADIUS . ( expression ) , color_expression }

    (               shift and go to state 60


state 55

    (17) point_expression -> POINT ( expression . , expression )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    ,               shift and go to state 61
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 56

    (16) rect_g -> RECT { point_expression , size_expression . , color_expression }

    ,               shift and go to state 62


state 57

    (18) size_expression -> SIZE . ( expression , expression )

    (               shift and go to state 63


state 58

    (11) translation -> TRANSLATE ( IDENTIFIER , point_expression . )

    )               shift and go to state 64


state 59

    (12) translation -> ROTATE ( IDENTIFIER , expression . )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    )               shift and go to state 65
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 60

    (15) circle_g -> CIRCLE { point_expression , RADIUS ( . expression ) , color_expression }
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 66

state 61

    (17) point_expression -> POINT ( expression , . expression )
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 67

state 62

    (16) rect_g -> RECT { point_expression , size_expression , . color_expression }
    (19) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 69

    color_expression               shift and go to state 68

state 63

    (18) size_expression -> SIZE ( . expression , expression )
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 70

state 64

    (11) translation -> TRANSLATE ( IDENTIFIER , point_expression ) .

    ;               reduce using rule 11 (translation -> TRANSLATE ( IDENTIFIER , point_expression ) .)
    $end            reduce using rule 11 (translation -> TRANSLATE ( IDENTIFIER , point_expression ) .)
    }               reduce using rule 11 (translation -> TRANSLATE ( IDENTIFIER , point_expression ) .)


state 65

    (12) translation -> ROTATE ( IDENTIFIER , expression ) .

    ;               reduce using rule 12 (translation -> ROTATE ( IDENTIFIER , expression ) .)
    $end            reduce using rule 12 (translation -> ROTATE ( IDENTIFIER , expression ) .)
    }               reduce using rule 12 (translation -> ROTATE ( IDENTIFIER , expression ) .)


state 66

    (15) circle_g -> CIRCLE { point_expression , RADIUS ( expression . ) , color_expression }
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    )               shift and go to state 71
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 67

    (17) point_expression -> POINT ( expression , expression . )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    )               shift and go to state 72
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 68

    (16) rect_g -> RECT { point_expression , size_expression , color_expression . }

    }               shift and go to state 73


state 69

    (19) color_expression -> COLOR . ( expression , expression , expression )

    (               shift and go to state 74


state 70

    (18) size_expression -> SIZE ( expression . , expression )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    ,               shift and go to state 75
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 71

    (15) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) . , color_expression }

    ,               shift and go to state 76


state 72

    (17) point_expression -> POINT ( expression , expression ) .

    ,               reduce using rule 17 (point_expression -> POINT ( expression , expression ) .)
    )               reduce using rule 17 (point_expression -> POINT ( expression , expression ) .)


state 73

    (16) rect_g -> RECT { point_expression , size_expression , color_expression } .

    ;               reduce using rule 16 (rect_g -> RECT { point_expression , size_expression , color_expression } .)
    $end            reduce using rule 16 (rect_g -> RECT { point_expression , size_expression , color_expression } .)
    }               reduce using rule 16 (rect_g -> RECT { point_expression , size_expression , color_expression } .)


state 74

    (19) color_expression -> COLOR ( . expression , expression , expression )
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 77

state 75

    (18) size_expression -> SIZE ( expression , . expression )
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 78

state 76

    (15) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , . color_expression }
    (19) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 69

    color_expression               shift and go to state 79

state 77

    (19) color_expression -> COLOR ( expression . , expression , expression )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    ,               shift and go to state 80
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 78

    (18) size_expression -> SIZE ( expression , expression . )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    )               shift and go to state 81
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 79

    (15) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression . }

    }               shift and go to state 82


state 80

    (19) color_expression -> COLOR ( expression , . expression , expression )
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 83

state 81

    (18) size_expression -> SIZE ( expression , expression ) .

    ,               reduce using rule 18 (size_expression -> SIZE ( expression , expression ) .)


state 82

    (15) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .

    ;               reduce using rule 15 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)
    $end            reduce using rule 15 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)
    }               reduce using rule 15 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)


state 83

    (19) color_expression -> COLOR ( expression , expression . , expression )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    ,               shift and go to state 84
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 84

    (19) color_expression -> COLOR ( expression , expression , . expression )
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . NUMBER
    (23) expression -> . IDENTIFIER
    (24) expression -> . ( expression )
    (25) expression -> . ADD_OP expression

    NUMBER          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 23
    ADD_OP          shift and go to state 20

    expression                     shift and go to state 85

state 85

    (19) color_expression -> COLOR ( expression , expression , expression . )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression

    )               shift and go to state 86
    ADD_OP          shift and go to state 31
    MUL_OP          shift and go to state 32


state 86

    (19) color_expression -> COLOR ( expression , expression , expression ) .

    }               reduce using rule 19 (color_expression -> COLOR ( expression , expression , expression ) .)

