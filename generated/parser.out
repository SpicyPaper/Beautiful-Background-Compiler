Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> subprogram
Rule 2     subprogram -> statement ;
Rule 3     subprogram -> statement ; subprogram
Rule 4     statement -> assignation
Rule 5     statement -> assignation_shape
Rule 6     statement -> structure
Rule 7     statement -> shape
Rule 8     statement -> animation
Rule 9     statement -> PRINT expression
Rule 10    structure -> FOR ( expression , expression , expression ) { subprogram }
Rule 11    animation -> translation
Rule 12    translation -> TRANSLATE ( animation_param , point_expression )
Rule 13    translation -> ROTATE ( animation_param , expression , AROUND ( point_expression ) )
Rule 14    animation_param -> IDENTIFIER
Rule 15    animation_param -> shape
Rule 16    shape -> circle_g
Rule 17    shape -> rect_g
Rule 18    shape -> polygon_g
Rule 19    circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
Rule 20    rect_g -> RECT { point_expression , size_expression , color_expression }
Rule 21    polygon_g -> POLYGON { ( points_expression ) , color_expression }
Rule 22    points_expression -> point_expression
Rule 23    points_expression -> point_expression , points_expression
Rule 24    point_expression -> POINT ( expression , expression )
Rule 25    size_expression -> SIZE ( expression , expression )
Rule 26    color_expression -> COLOR ( expression , expression , expression )
Rule 27    expression -> expression ADD_OP expression
Rule 28    expression -> expression MUL_OP expression
Rule 29    expression -> NUMBER
Rule 30    expression -> IDENTIFIER
Rule 31    expression -> ( expression )
Rule 32    expression -> ADD_OP expression
Rule 33    assignation_shape -> IDENTIFIER = shape
Rule 34    assignation -> IDENTIFIER = expression

Terminals, with rules where they appear

(                    : 10 12 13 13 19 21 24 25 26 31
)                    : 10 12 13 13 19 21 24 25 26 31
,                    : 10 10 12 13 13 19 19 20 20 21 23 24 25 26 26
;                    : 2 3
=                    : 33 34
ADD_OP               : 27 32
AROUND               : 13
CIRCLE               : 19
COLOR                : 26
FOR                  : 10
IDENTIFIER           : 14 30 33 34
MUL_OP               : 28
NUMBER               : 29
POINT                : 24
POLYGON              : 21
PRINT                : 9
RADIUS               : 19
RECT                 : 20
ROTATE               : 13
SIZE                 : 25
TRANSLATE            : 12
error                : 
{                    : 10 19 20 21
}                    : 10 19 20 21

Nonterminals, with rules where they appear

animation            : 8
animation_param      : 12 13
assignation          : 4
assignation_shape    : 5
circle_g             : 16
color_expression     : 19 20 21
expression           : 9 10 10 10 13 19 24 24 25 25 26 26 26 27 27 28 28 31 32 34
point_expression     : 12 13 19 20 22 23
points_expression    : 21 23
polygon_g            : 18
program              : 0
rect_g               : 17
shape                : 7 15 33
size_expression      : 20
statement            : 2 3
structure            : 6
subprogram           : 1 3 10
translation          : 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . subprogram
    (2) subprogram -> . statement ;
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . assignation_shape
    (6) statement -> . structure
    (7) statement -> . shape
    (8) statement -> . animation
    (9) statement -> . PRINT expression
    (34) assignation -> . IDENTIFIER = expression
    (33) assignation_shape -> . IDENTIFIER = shape
    (10) structure -> . FOR ( expression , expression , expression ) { subprogram }
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (18) shape -> . polygon_g
    (11) animation -> . translation
    (19) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (20) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (21) polygon_g -> . POLYGON { ( points_expression ) , color_expression }
    (12) translation -> . TRANSLATE ( animation_param , point_expression )
    (13) translation -> . ROTATE ( animation_param , expression , AROUND ( point_expression ) )

    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 10
    FOR             shift and go to state 11
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 17
    POLYGON         shift and go to state 18
    TRANSLATE       shift and go to state 19
    ROTATE          shift and go to state 20

    program                        shift and go to state 1
    subprogram                     shift and go to state 2
    statement                      shift and go to state 3
    assignation                    shift and go to state 4
    assignation_shape              shift and go to state 5
    structure                      shift and go to state 6
    shape                          shift and go to state 7
    animation                      shift and go to state 8
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13
    polygon_g                      shift and go to state 14
    translation                    shift and go to state 15

state 1

    (0) S' -> program .



state 2

    (1) program -> subprogram .

    $end            reduce using rule 1 (program -> subprogram .)


state 3

    (2) subprogram -> statement . ;
    (3) subprogram -> statement . ; subprogram

    ;               shift and go to state 21


state 4

    (4) statement -> assignation .

    ;               reduce using rule 4 (statement -> assignation .)


state 5

    (5) statement -> assignation_shape .

    ;               reduce using rule 5 (statement -> assignation_shape .)


state 6

    (6) statement -> structure .

    ;               reduce using rule 6 (statement -> structure .)


state 7

    (7) statement -> shape .

    ;               reduce using rule 7 (statement -> shape .)


state 8

    (8) statement -> animation .

    ;               reduce using rule 8 (statement -> animation .)


state 9

    (9) statement -> PRINT . expression
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 22

state 10

    (34) assignation -> IDENTIFIER . = expression
    (33) assignation_shape -> IDENTIFIER . = shape

    =               shift and go to state 27


state 11

    (10) structure -> FOR . ( expression , expression , expression ) { subprogram }

    (               shift and go to state 28


state 12

    (16) shape -> circle_g .

    ;               reduce using rule 16 (shape -> circle_g .)
    ,               reduce using rule 16 (shape -> circle_g .)


state 13

    (17) shape -> rect_g .

    ;               reduce using rule 17 (shape -> rect_g .)
    ,               reduce using rule 17 (shape -> rect_g .)


state 14

    (18) shape -> polygon_g .

    ;               reduce using rule 18 (shape -> polygon_g .)
    ,               reduce using rule 18 (shape -> polygon_g .)


state 15

    (11) animation -> translation .

    ;               reduce using rule 11 (animation -> translation .)


state 16

    (19) circle_g -> CIRCLE . { point_expression , RADIUS ( expression ) , color_expression }

    {               shift and go to state 29


state 17

    (20) rect_g -> RECT . { point_expression , size_expression , color_expression }

    {               shift and go to state 30


state 18

    (21) polygon_g -> POLYGON . { ( points_expression ) , color_expression }

    {               shift and go to state 31


state 19

    (12) translation -> TRANSLATE . ( animation_param , point_expression )

    (               shift and go to state 32


state 20

    (13) translation -> ROTATE . ( animation_param , expression , AROUND ( point_expression ) )

    (               shift and go to state 33


state 21

    (2) subprogram -> statement ; .
    (3) subprogram -> statement ; . subprogram
    (2) subprogram -> . statement ;
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . assignation_shape
    (6) statement -> . structure
    (7) statement -> . shape
    (8) statement -> . animation
    (9) statement -> . PRINT expression
    (34) assignation -> . IDENTIFIER = expression
    (33) assignation_shape -> . IDENTIFIER = shape
    (10) structure -> . FOR ( expression , expression , expression ) { subprogram }
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (18) shape -> . polygon_g
    (11) animation -> . translation
    (19) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (20) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (21) polygon_g -> . POLYGON { ( points_expression ) , color_expression }
    (12) translation -> . TRANSLATE ( animation_param , point_expression )
    (13) translation -> . ROTATE ( animation_param , expression , AROUND ( point_expression ) )

    $end            reduce using rule 2 (subprogram -> statement ; .)
    }               reduce using rule 2 (subprogram -> statement ; .)
    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 10
    FOR             shift and go to state 11
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 17
    POLYGON         shift and go to state 18
    TRANSLATE       shift and go to state 19
    ROTATE          shift and go to state 20

    statement                      shift and go to state 3
    subprogram                     shift and go to state 34
    assignation                    shift and go to state 4
    assignation_shape              shift and go to state 5
    structure                      shift and go to state 6
    shape                          shift and go to state 7
    animation                      shift and go to state 8
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13
    polygon_g                      shift and go to state 14
    translation                    shift and go to state 15

state 22

    (9) statement -> PRINT expression .
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ;               reduce using rule 9 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 23

    (32) expression -> ADD_OP . expression
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 37

state 24

    (29) expression -> NUMBER .

    ADD_OP          reduce using rule 29 (expression -> NUMBER .)
    MUL_OP          reduce using rule 29 (expression -> NUMBER .)
    ;               reduce using rule 29 (expression -> NUMBER .)
    )               reduce using rule 29 (expression -> NUMBER .)
    ,               reduce using rule 29 (expression -> NUMBER .)


state 25

    (30) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 30 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 30 (expression -> IDENTIFIER .)
    ;               reduce using rule 30 (expression -> IDENTIFIER .)
    )               reduce using rule 30 (expression -> IDENTIFIER .)
    ,               reduce using rule 30 (expression -> IDENTIFIER .)


state 26

    (31) expression -> ( . expression )
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 38

state 27

    (34) assignation -> IDENTIFIER = . expression
    (33) assignation_shape -> IDENTIFIER = . shape
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (18) shape -> . polygon_g
    (19) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (20) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (21) polygon_g -> . POLYGON { ( points_expression ) , color_expression }

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 17
    POLYGON         shift and go to state 18

    expression                     shift and go to state 39
    shape                          shift and go to state 40
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13
    polygon_g                      shift and go to state 14

state 28

    (10) structure -> FOR ( . expression , expression , expression ) { subprogram }
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 41

state 29

    (19) circle_g -> CIRCLE { . point_expression , RADIUS ( expression ) , color_expression }
    (24) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 43

    point_expression               shift and go to state 42

state 30

    (20) rect_g -> RECT { . point_expression , size_expression , color_expression }
    (24) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 43

    point_expression               shift and go to state 44

state 31

    (21) polygon_g -> POLYGON { . ( points_expression ) , color_expression }

    (               shift and go to state 45


state 32

    (12) translation -> TRANSLATE ( . animation_param , point_expression )
    (14) animation_param -> . IDENTIFIER
    (15) animation_param -> . shape
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (18) shape -> . polygon_g
    (19) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (20) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (21) polygon_g -> . POLYGON { ( points_expression ) , color_expression }

    IDENTIFIER      shift and go to state 47
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 17
    POLYGON         shift and go to state 18

    animation_param                shift and go to state 46
    shape                          shift and go to state 48
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13
    polygon_g                      shift and go to state 14

state 33

    (13) translation -> ROTATE ( . animation_param , expression , AROUND ( point_expression ) )
    (14) animation_param -> . IDENTIFIER
    (15) animation_param -> . shape
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (18) shape -> . polygon_g
    (19) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (20) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (21) polygon_g -> . POLYGON { ( points_expression ) , color_expression }

    IDENTIFIER      shift and go to state 47
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 17
    POLYGON         shift and go to state 18

    animation_param                shift and go to state 49
    shape                          shift and go to state 48
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13
    polygon_g                      shift and go to state 14

state 34

    (3) subprogram -> statement ; subprogram .

    $end            reduce using rule 3 (subprogram -> statement ; subprogram .)
    }               reduce using rule 3 (subprogram -> statement ; subprogram .)


state 35

    (27) expression -> expression ADD_OP . expression
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 50

state 36

    (28) expression -> expression MUL_OP . expression
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 51

state 37

    (32) expression -> ADD_OP expression .
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 32 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 32 (expression -> ADD_OP expression .)
    ;               reduce using rule 32 (expression -> ADD_OP expression .)
    )               reduce using rule 32 (expression -> ADD_OP expression .)
    ,               reduce using rule 32 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 35 ]
  ! MUL_OP          [ shift and go to state 36 ]


state 38

    (31) expression -> ( expression . )
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    )               shift and go to state 52
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 39

    (34) assignation -> IDENTIFIER = expression .
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ;               reduce using rule 34 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 40

    (33) assignation_shape -> IDENTIFIER = shape .

    ;               reduce using rule 33 (assignation_shape -> IDENTIFIER = shape .)


state 41

    (10) structure -> FOR ( expression . , expression , expression ) { subprogram }
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ,               shift and go to state 53
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 42

    (19) circle_g -> CIRCLE { point_expression . , RADIUS ( expression ) , color_expression }

    ,               shift and go to state 54


state 43

    (24) point_expression -> POINT . ( expression , expression )

    (               shift and go to state 55


state 44

    (20) rect_g -> RECT { point_expression . , size_expression , color_expression }

    ,               shift and go to state 56


state 45

    (21) polygon_g -> POLYGON { ( . points_expression ) , color_expression }
    (22) points_expression -> . point_expression
    (23) points_expression -> . point_expression , points_expression
    (24) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 43

    points_expression              shift and go to state 57
    point_expression               shift and go to state 58

state 46

    (12) translation -> TRANSLATE ( animation_param . , point_expression )

    ,               shift and go to state 59


state 47

    (14) animation_param -> IDENTIFIER .

    ,               reduce using rule 14 (animation_param -> IDENTIFIER .)


state 48

    (15) animation_param -> shape .

    ,               reduce using rule 15 (animation_param -> shape .)


state 49

    (13) translation -> ROTATE ( animation_param . , expression , AROUND ( point_expression ) )

    ,               shift and go to state 60


state 50

    (27) expression -> expression ADD_OP expression .
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 27 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 27 (expression -> expression ADD_OP expression .)
    )               reduce using rule 27 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 27 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 36

  ! MUL_OP          [ reduce using rule 27 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 35 ]


state 51

    (28) expression -> expression MUL_OP expression .
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 28 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 28 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 28 (expression -> expression MUL_OP expression .)
    )               reduce using rule 28 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 28 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 35 ]
  ! MUL_OP          [ shift and go to state 36 ]


state 52

    (31) expression -> ( expression ) .

    ADD_OP          reduce using rule 31 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 31 (expression -> ( expression ) .)
    ;               reduce using rule 31 (expression -> ( expression ) .)
    )               reduce using rule 31 (expression -> ( expression ) .)
    ,               reduce using rule 31 (expression -> ( expression ) .)


state 53

    (10) structure -> FOR ( expression , . expression , expression ) { subprogram }
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 61

state 54

    (19) circle_g -> CIRCLE { point_expression , . RADIUS ( expression ) , color_expression }

    RADIUS          shift and go to state 62


state 55

    (24) point_expression -> POINT ( . expression , expression )
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 63

state 56

    (20) rect_g -> RECT { point_expression , . size_expression , color_expression }
    (25) size_expression -> . SIZE ( expression , expression )

    SIZE            shift and go to state 65

    size_expression                shift and go to state 64

state 57

    (21) polygon_g -> POLYGON { ( points_expression . ) , color_expression }

    )               shift and go to state 66


state 58

    (22) points_expression -> point_expression .
    (23) points_expression -> point_expression . , points_expression

    )               reduce using rule 22 (points_expression -> point_expression .)
    ,               shift and go to state 67


state 59

    (12) translation -> TRANSLATE ( animation_param , . point_expression )
    (24) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 43

    point_expression               shift and go to state 68

state 60

    (13) translation -> ROTATE ( animation_param , . expression , AROUND ( point_expression ) )
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 69

state 61

    (10) structure -> FOR ( expression , expression . , expression ) { subprogram }
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ,               shift and go to state 70
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 62

    (19) circle_g -> CIRCLE { point_expression , RADIUS . ( expression ) , color_expression }

    (               shift and go to state 71


state 63

    (24) point_expression -> POINT ( expression . , expression )
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ,               shift and go to state 72
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 64

    (20) rect_g -> RECT { point_expression , size_expression . , color_expression }

    ,               shift and go to state 73


state 65

    (25) size_expression -> SIZE . ( expression , expression )

    (               shift and go to state 74


state 66

    (21) polygon_g -> POLYGON { ( points_expression ) . , color_expression }

    ,               shift and go to state 75


state 67

    (23) points_expression -> point_expression , . points_expression
    (22) points_expression -> . point_expression
    (23) points_expression -> . point_expression , points_expression
    (24) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 43

    point_expression               shift and go to state 58
    points_expression              shift and go to state 76

state 68

    (12) translation -> TRANSLATE ( animation_param , point_expression . )

    )               shift and go to state 77


state 69

    (13) translation -> ROTATE ( animation_param , expression . , AROUND ( point_expression ) )
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ,               shift and go to state 78
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 70

    (10) structure -> FOR ( expression , expression , . expression ) { subprogram }
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 79

state 71

    (19) circle_g -> CIRCLE { point_expression , RADIUS ( . expression ) , color_expression }
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 80

state 72

    (24) point_expression -> POINT ( expression , . expression )
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 81

state 73

    (20) rect_g -> RECT { point_expression , size_expression , . color_expression }
    (26) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 83

    color_expression               shift and go to state 82

state 74

    (25) size_expression -> SIZE ( . expression , expression )
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 84

state 75

    (21) polygon_g -> POLYGON { ( points_expression ) , . color_expression }
    (26) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 83

    color_expression               shift and go to state 85

state 76

    (23) points_expression -> point_expression , points_expression .

    )               reduce using rule 23 (points_expression -> point_expression , points_expression .)


state 77

    (12) translation -> TRANSLATE ( animation_param , point_expression ) .

    ;               reduce using rule 12 (translation -> TRANSLATE ( animation_param , point_expression ) .)


state 78

    (13) translation -> ROTATE ( animation_param , expression , . AROUND ( point_expression ) )

    AROUND          shift and go to state 86


state 79

    (10) structure -> FOR ( expression , expression , expression . ) { subprogram }
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    )               shift and go to state 87
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 80

    (19) circle_g -> CIRCLE { point_expression , RADIUS ( expression . ) , color_expression }
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    )               shift and go to state 88
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 81

    (24) point_expression -> POINT ( expression , expression . )
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    )               shift and go to state 89
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 82

    (20) rect_g -> RECT { point_expression , size_expression , color_expression . }

    }               shift and go to state 90


state 83

    (26) color_expression -> COLOR . ( expression , expression , expression )

    (               shift and go to state 91


state 84

    (25) size_expression -> SIZE ( expression . , expression )
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ,               shift and go to state 92
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 85

    (21) polygon_g -> POLYGON { ( points_expression ) , color_expression . }

    }               shift and go to state 93


state 86

    (13) translation -> ROTATE ( animation_param , expression , AROUND . ( point_expression ) )

    (               shift and go to state 94


state 87

    (10) structure -> FOR ( expression , expression , expression ) . { subprogram }

    {               shift and go to state 95


state 88

    (19) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) . , color_expression }

    ,               shift and go to state 96


state 89

    (24) point_expression -> POINT ( expression , expression ) .

    ,               reduce using rule 24 (point_expression -> POINT ( expression , expression ) .)
    )               reduce using rule 24 (point_expression -> POINT ( expression , expression ) .)


state 90

    (20) rect_g -> RECT { point_expression , size_expression , color_expression } .

    ;               reduce using rule 20 (rect_g -> RECT { point_expression , size_expression , color_expression } .)
    ,               reduce using rule 20 (rect_g -> RECT { point_expression , size_expression , color_expression } .)


state 91

    (26) color_expression -> COLOR ( . expression , expression , expression )
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 97

state 92

    (25) size_expression -> SIZE ( expression , . expression )
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 98

state 93

    (21) polygon_g -> POLYGON { ( points_expression ) , color_expression } .

    ;               reduce using rule 21 (polygon_g -> POLYGON { ( points_expression ) , color_expression } .)
    ,               reduce using rule 21 (polygon_g -> POLYGON { ( points_expression ) , color_expression } .)


state 94

    (13) translation -> ROTATE ( animation_param , expression , AROUND ( . point_expression ) )
    (24) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 43

    point_expression               shift and go to state 99

state 95

    (10) structure -> FOR ( expression , expression , expression ) { . subprogram }
    (2) subprogram -> . statement ;
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . assignation_shape
    (6) statement -> . structure
    (7) statement -> . shape
    (8) statement -> . animation
    (9) statement -> . PRINT expression
    (34) assignation -> . IDENTIFIER = expression
    (33) assignation_shape -> . IDENTIFIER = shape
    (10) structure -> . FOR ( expression , expression , expression ) { subprogram }
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (18) shape -> . polygon_g
    (11) animation -> . translation
    (19) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (20) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (21) polygon_g -> . POLYGON { ( points_expression ) , color_expression }
    (12) translation -> . TRANSLATE ( animation_param , point_expression )
    (13) translation -> . ROTATE ( animation_param , expression , AROUND ( point_expression ) )

    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 10
    FOR             shift and go to state 11
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 17
    POLYGON         shift and go to state 18
    TRANSLATE       shift and go to state 19
    ROTATE          shift and go to state 20

    subprogram                     shift and go to state 100
    statement                      shift and go to state 3
    assignation                    shift and go to state 4
    assignation_shape              shift and go to state 5
    structure                      shift and go to state 6
    shape                          shift and go to state 7
    animation                      shift and go to state 8
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13
    polygon_g                      shift and go to state 14
    translation                    shift and go to state 15

state 96

    (19) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , . color_expression }
    (26) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 83

    color_expression               shift and go to state 101

state 97

    (26) color_expression -> COLOR ( expression . , expression , expression )
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ,               shift and go to state 102
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 98

    (25) size_expression -> SIZE ( expression , expression . )
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    )               shift and go to state 103
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 99

    (13) translation -> ROTATE ( animation_param , expression , AROUND ( point_expression . ) )

    )               shift and go to state 104


state 100

    (10) structure -> FOR ( expression , expression , expression ) { subprogram . }

    }               shift and go to state 105


state 101

    (19) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression . }

    }               shift and go to state 106


state 102

    (26) color_expression -> COLOR ( expression , . expression , expression )
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 107

state 103

    (25) size_expression -> SIZE ( expression , expression ) .

    ,               reduce using rule 25 (size_expression -> SIZE ( expression , expression ) .)


state 104

    (13) translation -> ROTATE ( animation_param , expression , AROUND ( point_expression ) . )

    )               shift and go to state 108


state 105

    (10) structure -> FOR ( expression , expression , expression ) { subprogram } .

    ;               reduce using rule 10 (structure -> FOR ( expression , expression , expression ) { subprogram } .)


state 106

    (19) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .

    ;               reduce using rule 19 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)
    ,               reduce using rule 19 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)


state 107

    (26) color_expression -> COLOR ( expression , expression . , expression )
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    ,               shift and go to state 109
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 108

    (13) translation -> ROTATE ( animation_param , expression , AROUND ( point_expression ) ) .

    ;               reduce using rule 13 (translation -> ROTATE ( animation_param , expression , AROUND ( point_expression ) ) .)


state 109

    (26) color_expression -> COLOR ( expression , expression , . expression )
    (27) expression -> . expression ADD_OP expression
    (28) expression -> . expression MUL_OP expression
    (29) expression -> . NUMBER
    (30) expression -> . IDENTIFIER
    (31) expression -> . ( expression )
    (32) expression -> . ADD_OP expression

    NUMBER          shift and go to state 24
    IDENTIFIER      shift and go to state 25
    (               shift and go to state 26
    ADD_OP          shift and go to state 23

    expression                     shift and go to state 110

state 110

    (26) color_expression -> COLOR ( expression , expression , expression . )
    (27) expression -> expression . ADD_OP expression
    (28) expression -> expression . MUL_OP expression

    )               shift and go to state 111
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 111

    (26) color_expression -> COLOR ( expression , expression , expression ) .

    }               reduce using rule 26 (color_expression -> COLOR ( expression , expression , expression ) .)

