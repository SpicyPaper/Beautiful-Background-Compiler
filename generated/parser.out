Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> subprogram
Rule 2     subprogram -> statement ;
Rule 3     subprogram -> statement ; subprogram
Rule 4     statement -> assignation
Rule 5     statement -> assignation_shape
Rule 6     statement -> assignation_color
Rule 7     statement -> structure
Rule 8     statement -> shape
Rule 9     statement -> animation
Rule 10    statement -> PRINT expression
Rule 11    structure -> FOR ( expression , expression , expression ) { subprogram }
Rule 12    animation -> translation
Rule 13    translation -> TRANSLATE ( animation_param , point_expression )
Rule 14    translation -> ROTATE ( animation_param , expression , AROUND ( point_expression ) )
Rule 15    animation_param -> IDENTIFIER
Rule 16    animation_param -> shape
Rule 17    shape -> circle_g
Rule 18    shape -> rect_g
Rule 19    shape -> polygon_g
Rule 20    circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
Rule 21    rect_g -> RECT { point_expression , size_expression , color_expression }
Rule 22    polygon_g -> POLYGON { ( points_expression ) , color_expression }
Rule 23    points_expression -> point_expression
Rule 24    points_expression -> point_expression , points_expression
Rule 25    point_expression -> POINT ( expression , expression )
Rule 26    size_expression -> SIZE ( expression , expression )
Rule 27    color_expression -> COLOR ( expression , expression , expression )
Rule 28    expression -> expression ADD_OP expression
Rule 29    expression -> expression MUL_OP expression
Rule 30    expression -> NUMBER
Rule 31    expression -> IDENTIFIER
Rule 32    expression -> ( expression )
Rule 33    expression -> ADD_OP expression
Rule 34    assignation_color -> IDENTIFIER = color_expression
Rule 35    assignation_shape -> IDENTIFIER = shape
Rule 36    assignation -> IDENTIFIER = expression
Rule 37    expression -> RANDOM ( expression )
Rule 38    expression -> RANDOM ( expression , expression )

Terminals, with rules where they appear

(                    : 11 13 14 14 20 22 25 26 27 32 37 38
)                    : 11 13 14 14 20 22 25 26 27 32 37 38
,                    : 11 11 13 14 14 20 20 21 21 22 24 25 26 27 27 38
;                    : 2 3
=                    : 34 35 36
ADD_OP               : 28 33
AROUND               : 14
CIRCLE               : 20
COLOR                : 27
FOR                  : 11
IDENTIFIER           : 15 31 34 35 36
MUL_OP               : 29
NUMBER               : 30
POINT                : 25
POLYGON              : 22
PRINT                : 10
RADIUS               : 20
RANDOM               : 37 38
RECT                 : 21
ROTATE               : 14
SIZE                 : 26
TRANSLATE            : 13
error                : 
{                    : 11 20 21 22
}                    : 11 20 21 22

Nonterminals, with rules where they appear

animation            : 9
animation_param      : 13 14
assignation          : 4
assignation_color    : 6
assignation_shape    : 5
circle_g             : 17
color_expression     : 20 21 22 34
expression           : 10 11 11 11 14 20 25 25 26 26 27 27 27 28 28 29 29 32 33 36 37 38 38
point_expression     : 13 14 20 21 23 24
points_expression    : 22 24
polygon_g            : 19
program              : 0
rect_g               : 18
shape                : 8 16 35
size_expression      : 21
statement            : 2 3
structure            : 7
subprogram           : 1 3 11
translation          : 12

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . subprogram
    (2) subprogram -> . statement ;
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . assignation_shape
    (6) statement -> . assignation_color
    (7) statement -> . structure
    (8) statement -> . shape
    (9) statement -> . animation
    (10) statement -> . PRINT expression
    (36) assignation -> . IDENTIFIER = expression
    (35) assignation_shape -> . IDENTIFIER = shape
    (34) assignation_color -> . IDENTIFIER = color_expression
    (11) structure -> . FOR ( expression , expression , expression ) { subprogram }
    (17) shape -> . circle_g
    (18) shape -> . rect_g
    (19) shape -> . polygon_g
    (12) animation -> . translation
    (20) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (21) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (22) polygon_g -> . POLYGON { ( points_expression ) , color_expression }
    (13) translation -> . TRANSLATE ( animation_param , point_expression )
    (14) translation -> . ROTATE ( animation_param , expression , AROUND ( point_expression ) )

    PRINT           shift and go to state 10
    IDENTIFIER      shift and go to state 11
    FOR             shift and go to state 12
    CIRCLE          shift and go to state 17
    RECT            shift and go to state 18
    POLYGON         shift and go to state 19
    TRANSLATE       shift and go to state 20
    ROTATE          shift and go to state 21

    program                        shift and go to state 1
    subprogram                     shift and go to state 2
    statement                      shift and go to state 3
    assignation                    shift and go to state 4
    assignation_shape              shift and go to state 5
    assignation_color              shift and go to state 6
    structure                      shift and go to state 7
    shape                          shift and go to state 8
    animation                      shift and go to state 9
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14
    polygon_g                      shift and go to state 15
    translation                    shift and go to state 16

state 1

    (0) S' -> program .



state 2

    (1) program -> subprogram .

    $end            reduce using rule 1 (program -> subprogram .)


state 3

    (2) subprogram -> statement . ;
    (3) subprogram -> statement . ; subprogram

    ;               shift and go to state 22


state 4

    (4) statement -> assignation .

    ;               reduce using rule 4 (statement -> assignation .)


state 5

    (5) statement -> assignation_shape .

    ;               reduce using rule 5 (statement -> assignation_shape .)


state 6

    (6) statement -> assignation_color .

    ;               reduce using rule 6 (statement -> assignation_color .)


state 7

    (7) statement -> structure .

    ;               reduce using rule 7 (statement -> structure .)


state 8

    (8) statement -> shape .

    ;               reduce using rule 8 (statement -> shape .)


state 9

    (9) statement -> animation .

    ;               reduce using rule 9 (statement -> animation .)


state 10

    (10) statement -> PRINT . expression
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 23

state 11

    (36) assignation -> IDENTIFIER . = expression
    (35) assignation_shape -> IDENTIFIER . = shape
    (34) assignation_color -> IDENTIFIER . = color_expression

    =               shift and go to state 29


state 12

    (11) structure -> FOR . ( expression , expression , expression ) { subprogram }

    (               shift and go to state 30


state 13

    (17) shape -> circle_g .

    ;               reduce using rule 17 (shape -> circle_g .)
    ,               reduce using rule 17 (shape -> circle_g .)


state 14

    (18) shape -> rect_g .

    ;               reduce using rule 18 (shape -> rect_g .)
    ,               reduce using rule 18 (shape -> rect_g .)


state 15

    (19) shape -> polygon_g .

    ;               reduce using rule 19 (shape -> polygon_g .)
    ,               reduce using rule 19 (shape -> polygon_g .)


state 16

    (12) animation -> translation .

    ;               reduce using rule 12 (animation -> translation .)


state 17

    (20) circle_g -> CIRCLE . { point_expression , RADIUS ( expression ) , color_expression }

    {               shift and go to state 31


state 18

    (21) rect_g -> RECT . { point_expression , size_expression , color_expression }

    {               shift and go to state 32


state 19

    (22) polygon_g -> POLYGON . { ( points_expression ) , color_expression }

    {               shift and go to state 33


state 20

    (13) translation -> TRANSLATE . ( animation_param , point_expression )

    (               shift and go to state 34


state 21

    (14) translation -> ROTATE . ( animation_param , expression , AROUND ( point_expression ) )

    (               shift and go to state 35


state 22

    (2) subprogram -> statement ; .
    (3) subprogram -> statement ; . subprogram
    (2) subprogram -> . statement ;
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . assignation_shape
    (6) statement -> . assignation_color
    (7) statement -> . structure
    (8) statement -> . shape
    (9) statement -> . animation
    (10) statement -> . PRINT expression
    (36) assignation -> . IDENTIFIER = expression
    (35) assignation_shape -> . IDENTIFIER = shape
    (34) assignation_color -> . IDENTIFIER = color_expression
    (11) structure -> . FOR ( expression , expression , expression ) { subprogram }
    (17) shape -> . circle_g
    (18) shape -> . rect_g
    (19) shape -> . polygon_g
    (12) animation -> . translation
    (20) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (21) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (22) polygon_g -> . POLYGON { ( points_expression ) , color_expression }
    (13) translation -> . TRANSLATE ( animation_param , point_expression )
    (14) translation -> . ROTATE ( animation_param , expression , AROUND ( point_expression ) )

    $end            reduce using rule 2 (subprogram -> statement ; .)
    }               reduce using rule 2 (subprogram -> statement ; .)
    PRINT           shift and go to state 10
    IDENTIFIER      shift and go to state 11
    FOR             shift and go to state 12
    CIRCLE          shift and go to state 17
    RECT            shift and go to state 18
    POLYGON         shift and go to state 19
    TRANSLATE       shift and go to state 20
    ROTATE          shift and go to state 21

    statement                      shift and go to state 3
    subprogram                     shift and go to state 36
    assignation                    shift and go to state 4
    assignation_shape              shift and go to state 5
    assignation_color              shift and go to state 6
    structure                      shift and go to state 7
    shape                          shift and go to state 8
    animation                      shift and go to state 9
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14
    polygon_g                      shift and go to state 15
    translation                    shift and go to state 16

state 23

    (10) statement -> PRINT expression .
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ;               reduce using rule 10 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 24

    (33) expression -> ADD_OP . expression
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 39

state 25

    (30) expression -> NUMBER .

    ADD_OP          reduce using rule 30 (expression -> NUMBER .)
    MUL_OP          reduce using rule 30 (expression -> NUMBER .)
    ;               reduce using rule 30 (expression -> NUMBER .)
    )               reduce using rule 30 (expression -> NUMBER .)
    ,               reduce using rule 30 (expression -> NUMBER .)


state 26

    (31) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 31 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 31 (expression -> IDENTIFIER .)
    ;               reduce using rule 31 (expression -> IDENTIFIER .)
    )               reduce using rule 31 (expression -> IDENTIFIER .)
    ,               reduce using rule 31 (expression -> IDENTIFIER .)


state 27

    (32) expression -> ( . expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 40

state 28

    (37) expression -> RANDOM . ( expression )
    (38) expression -> RANDOM . ( expression , expression )

    (               shift and go to state 41


state 29

    (36) assignation -> IDENTIFIER = . expression
    (35) assignation_shape -> IDENTIFIER = . shape
    (34) assignation_color -> IDENTIFIER = . color_expression
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )
    (17) shape -> . circle_g
    (18) shape -> . rect_g
    (19) shape -> . polygon_g
    (27) color_expression -> . COLOR ( expression , expression , expression )
    (20) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (21) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (22) polygon_g -> . POLYGON { ( points_expression ) , color_expression }

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28
    COLOR           shift and go to state 45
    CIRCLE          shift and go to state 17
    RECT            shift and go to state 18
    POLYGON         shift and go to state 19

    expression                     shift and go to state 42
    shape                          shift and go to state 43
    color_expression               shift and go to state 44
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14
    polygon_g                      shift and go to state 15

state 30

    (11) structure -> FOR ( . expression , expression , expression ) { subprogram }
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 46

state 31

    (20) circle_g -> CIRCLE { . point_expression , RADIUS ( expression ) , color_expression }
    (25) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 48

    point_expression               shift and go to state 47

state 32

    (21) rect_g -> RECT { . point_expression , size_expression , color_expression }
    (25) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 48

    point_expression               shift and go to state 49

state 33

    (22) polygon_g -> POLYGON { . ( points_expression ) , color_expression }

    (               shift and go to state 50


state 34

    (13) translation -> TRANSLATE ( . animation_param , point_expression )
    (15) animation_param -> . IDENTIFIER
    (16) animation_param -> . shape
    (17) shape -> . circle_g
    (18) shape -> . rect_g
    (19) shape -> . polygon_g
    (20) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (21) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (22) polygon_g -> . POLYGON { ( points_expression ) , color_expression }

    IDENTIFIER      shift and go to state 52
    CIRCLE          shift and go to state 17
    RECT            shift and go to state 18
    POLYGON         shift and go to state 19

    animation_param                shift and go to state 51
    shape                          shift and go to state 53
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14
    polygon_g                      shift and go to state 15

state 35

    (14) translation -> ROTATE ( . animation_param , expression , AROUND ( point_expression ) )
    (15) animation_param -> . IDENTIFIER
    (16) animation_param -> . shape
    (17) shape -> . circle_g
    (18) shape -> . rect_g
    (19) shape -> . polygon_g
    (20) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (21) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (22) polygon_g -> . POLYGON { ( points_expression ) , color_expression }

    IDENTIFIER      shift and go to state 52
    CIRCLE          shift and go to state 17
    RECT            shift and go to state 18
    POLYGON         shift and go to state 19

    animation_param                shift and go to state 54
    shape                          shift and go to state 53
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14
    polygon_g                      shift and go to state 15

state 36

    (3) subprogram -> statement ; subprogram .

    $end            reduce using rule 3 (subprogram -> statement ; subprogram .)
    }               reduce using rule 3 (subprogram -> statement ; subprogram .)


state 37

    (28) expression -> expression ADD_OP . expression
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 55

state 38

    (29) expression -> expression MUL_OP . expression
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 56

state 39

    (33) expression -> ADD_OP expression .
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 33 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 33 (expression -> ADD_OP expression .)
    ;               reduce using rule 33 (expression -> ADD_OP expression .)
    )               reduce using rule 33 (expression -> ADD_OP expression .)
    ,               reduce using rule 33 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 37 ]
  ! MUL_OP          [ shift and go to state 38 ]


state 40

    (32) expression -> ( expression . )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    )               shift and go to state 57
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 41

    (37) expression -> RANDOM ( . expression )
    (38) expression -> RANDOM ( . expression , expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 58

state 42

    (36) assignation -> IDENTIFIER = expression .
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ;               reduce using rule 36 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 43

    (35) assignation_shape -> IDENTIFIER = shape .

    ;               reduce using rule 35 (assignation_shape -> IDENTIFIER = shape .)


state 44

    (34) assignation_color -> IDENTIFIER = color_expression .

    ;               reduce using rule 34 (assignation_color -> IDENTIFIER = color_expression .)


state 45

    (27) color_expression -> COLOR . ( expression , expression , expression )

    (               shift and go to state 59


state 46

    (11) structure -> FOR ( expression . , expression , expression ) { subprogram }
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ,               shift and go to state 60
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 47

    (20) circle_g -> CIRCLE { point_expression . , RADIUS ( expression ) , color_expression }

    ,               shift and go to state 61


state 48

    (25) point_expression -> POINT . ( expression , expression )

    (               shift and go to state 62


state 49

    (21) rect_g -> RECT { point_expression . , size_expression , color_expression }

    ,               shift and go to state 63


state 50

    (22) polygon_g -> POLYGON { ( . points_expression ) , color_expression }
    (23) points_expression -> . point_expression
    (24) points_expression -> . point_expression , points_expression
    (25) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 48

    points_expression              shift and go to state 64
    point_expression               shift and go to state 65

state 51

    (13) translation -> TRANSLATE ( animation_param . , point_expression )

    ,               shift and go to state 66


state 52

    (15) animation_param -> IDENTIFIER .

    ,               reduce using rule 15 (animation_param -> IDENTIFIER .)


state 53

    (16) animation_param -> shape .

    ,               reduce using rule 16 (animation_param -> shape .)


state 54

    (14) translation -> ROTATE ( animation_param . , expression , AROUND ( point_expression ) )

    ,               shift and go to state 67


state 55

    (28) expression -> expression ADD_OP expression .
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 28 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 28 (expression -> expression ADD_OP expression .)
    )               reduce using rule 28 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 28 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 38

  ! MUL_OP          [ reduce using rule 28 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 37 ]


state 56

    (29) expression -> expression MUL_OP expression .
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 29 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 29 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 29 (expression -> expression MUL_OP expression .)
    )               reduce using rule 29 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 29 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 37 ]
  ! MUL_OP          [ shift and go to state 38 ]


state 57

    (32) expression -> ( expression ) .

    ADD_OP          reduce using rule 32 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 32 (expression -> ( expression ) .)
    ;               reduce using rule 32 (expression -> ( expression ) .)
    )               reduce using rule 32 (expression -> ( expression ) .)
    ,               reduce using rule 32 (expression -> ( expression ) .)


state 58

    (37) expression -> RANDOM ( expression . )
    (38) expression -> RANDOM ( expression . , expression )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    )               shift and go to state 68
    ,               shift and go to state 69
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 59

    (27) color_expression -> COLOR ( . expression , expression , expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 70

state 60

    (11) structure -> FOR ( expression , . expression , expression ) { subprogram }
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 71

state 61

    (20) circle_g -> CIRCLE { point_expression , . RADIUS ( expression ) , color_expression }

    RADIUS          shift and go to state 72


state 62

    (25) point_expression -> POINT ( . expression , expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 73

state 63

    (21) rect_g -> RECT { point_expression , . size_expression , color_expression }
    (26) size_expression -> . SIZE ( expression , expression )

    SIZE            shift and go to state 75

    size_expression                shift and go to state 74

state 64

    (22) polygon_g -> POLYGON { ( points_expression . ) , color_expression }

    )               shift and go to state 76


state 65

    (23) points_expression -> point_expression .
    (24) points_expression -> point_expression . , points_expression

    )               reduce using rule 23 (points_expression -> point_expression .)
    ,               shift and go to state 77


state 66

    (13) translation -> TRANSLATE ( animation_param , . point_expression )
    (25) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 48

    point_expression               shift and go to state 78

state 67

    (14) translation -> ROTATE ( animation_param , . expression , AROUND ( point_expression ) )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 79

state 68

    (37) expression -> RANDOM ( expression ) .

    ADD_OP          reduce using rule 37 (expression -> RANDOM ( expression ) .)
    MUL_OP          reduce using rule 37 (expression -> RANDOM ( expression ) .)
    ;               reduce using rule 37 (expression -> RANDOM ( expression ) .)
    )               reduce using rule 37 (expression -> RANDOM ( expression ) .)
    ,               reduce using rule 37 (expression -> RANDOM ( expression ) .)


state 69

    (38) expression -> RANDOM ( expression , . expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 80

state 70

    (27) color_expression -> COLOR ( expression . , expression , expression )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ,               shift and go to state 81
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 71

    (11) structure -> FOR ( expression , expression . , expression ) { subprogram }
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ,               shift and go to state 82
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 72

    (20) circle_g -> CIRCLE { point_expression , RADIUS . ( expression ) , color_expression }

    (               shift and go to state 83


state 73

    (25) point_expression -> POINT ( expression . , expression )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ,               shift and go to state 84
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 74

    (21) rect_g -> RECT { point_expression , size_expression . , color_expression }

    ,               shift and go to state 85


state 75

    (26) size_expression -> SIZE . ( expression , expression )

    (               shift and go to state 86


state 76

    (22) polygon_g -> POLYGON { ( points_expression ) . , color_expression }

    ,               shift and go to state 87


state 77

    (24) points_expression -> point_expression , . points_expression
    (23) points_expression -> . point_expression
    (24) points_expression -> . point_expression , points_expression
    (25) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 48

    point_expression               shift and go to state 65
    points_expression              shift and go to state 88

state 78

    (13) translation -> TRANSLATE ( animation_param , point_expression . )

    )               shift and go to state 89


state 79

    (14) translation -> ROTATE ( animation_param , expression . , AROUND ( point_expression ) )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ,               shift and go to state 90
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 80

    (38) expression -> RANDOM ( expression , expression . )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    )               shift and go to state 91
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 81

    (27) color_expression -> COLOR ( expression , . expression , expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 92

state 82

    (11) structure -> FOR ( expression , expression , . expression ) { subprogram }
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 93

state 83

    (20) circle_g -> CIRCLE { point_expression , RADIUS ( . expression ) , color_expression }
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 94

state 84

    (25) point_expression -> POINT ( expression , . expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 95

state 85

    (21) rect_g -> RECT { point_expression , size_expression , . color_expression }
    (27) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 45

    color_expression               shift and go to state 96

state 86

    (26) size_expression -> SIZE ( . expression , expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 97

state 87

    (22) polygon_g -> POLYGON { ( points_expression ) , . color_expression }
    (27) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 45

    color_expression               shift and go to state 98

state 88

    (24) points_expression -> point_expression , points_expression .

    )               reduce using rule 24 (points_expression -> point_expression , points_expression .)


state 89

    (13) translation -> TRANSLATE ( animation_param , point_expression ) .

    ;               reduce using rule 13 (translation -> TRANSLATE ( animation_param , point_expression ) .)


state 90

    (14) translation -> ROTATE ( animation_param , expression , . AROUND ( point_expression ) )

    AROUND          shift and go to state 99


state 91

    (38) expression -> RANDOM ( expression , expression ) .

    ADD_OP          reduce using rule 38 (expression -> RANDOM ( expression , expression ) .)
    MUL_OP          reduce using rule 38 (expression -> RANDOM ( expression , expression ) .)
    ;               reduce using rule 38 (expression -> RANDOM ( expression , expression ) .)
    )               reduce using rule 38 (expression -> RANDOM ( expression , expression ) .)
    ,               reduce using rule 38 (expression -> RANDOM ( expression , expression ) .)


state 92

    (27) color_expression -> COLOR ( expression , expression . , expression )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ,               shift and go to state 100
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 93

    (11) structure -> FOR ( expression , expression , expression . ) { subprogram }
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    )               shift and go to state 101
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 94

    (20) circle_g -> CIRCLE { point_expression , RADIUS ( expression . ) , color_expression }
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    )               shift and go to state 102
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 95

    (25) point_expression -> POINT ( expression , expression . )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    )               shift and go to state 103
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 96

    (21) rect_g -> RECT { point_expression , size_expression , color_expression . }

    }               shift and go to state 104


state 97

    (26) size_expression -> SIZE ( expression . , expression )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    ,               shift and go to state 105
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 98

    (22) polygon_g -> POLYGON { ( points_expression ) , color_expression . }

    }               shift and go to state 106


state 99

    (14) translation -> ROTATE ( animation_param , expression , AROUND . ( point_expression ) )

    (               shift and go to state 107


state 100

    (27) color_expression -> COLOR ( expression , expression , . expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 108

state 101

    (11) structure -> FOR ( expression , expression , expression ) . { subprogram }

    {               shift and go to state 109


state 102

    (20) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) . , color_expression }

    ,               shift and go to state 110


state 103

    (25) point_expression -> POINT ( expression , expression ) .

    ,               reduce using rule 25 (point_expression -> POINT ( expression , expression ) .)
    )               reduce using rule 25 (point_expression -> POINT ( expression , expression ) .)


state 104

    (21) rect_g -> RECT { point_expression , size_expression , color_expression } .

    ;               reduce using rule 21 (rect_g -> RECT { point_expression , size_expression , color_expression } .)
    ,               reduce using rule 21 (rect_g -> RECT { point_expression , size_expression , color_expression } .)


state 105

    (26) size_expression -> SIZE ( expression , . expression )
    (28) expression -> . expression ADD_OP expression
    (29) expression -> . expression MUL_OP expression
    (30) expression -> . NUMBER
    (31) expression -> . IDENTIFIER
    (32) expression -> . ( expression )
    (33) expression -> . ADD_OP expression
    (37) expression -> . RANDOM ( expression )
    (38) expression -> . RANDOM ( expression , expression )

    NUMBER          shift and go to state 25
    IDENTIFIER      shift and go to state 26
    (               shift and go to state 27
    ADD_OP          shift and go to state 24
    RANDOM          shift and go to state 28

    expression                     shift and go to state 111

state 106

    (22) polygon_g -> POLYGON { ( points_expression ) , color_expression } .

    ;               reduce using rule 22 (polygon_g -> POLYGON { ( points_expression ) , color_expression } .)
    ,               reduce using rule 22 (polygon_g -> POLYGON { ( points_expression ) , color_expression } .)


state 107

    (14) translation -> ROTATE ( animation_param , expression , AROUND ( . point_expression ) )
    (25) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 48

    point_expression               shift and go to state 112

state 108

    (27) color_expression -> COLOR ( expression , expression , expression . )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    )               shift and go to state 113
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 109

    (11) structure -> FOR ( expression , expression , expression ) { . subprogram }
    (2) subprogram -> . statement ;
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . assignation_shape
    (6) statement -> . assignation_color
    (7) statement -> . structure
    (8) statement -> . shape
    (9) statement -> . animation
    (10) statement -> . PRINT expression
    (36) assignation -> . IDENTIFIER = expression
    (35) assignation_shape -> . IDENTIFIER = shape
    (34) assignation_color -> . IDENTIFIER = color_expression
    (11) structure -> . FOR ( expression , expression , expression ) { subprogram }
    (17) shape -> . circle_g
    (18) shape -> . rect_g
    (19) shape -> . polygon_g
    (12) animation -> . translation
    (20) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (21) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (22) polygon_g -> . POLYGON { ( points_expression ) , color_expression }
    (13) translation -> . TRANSLATE ( animation_param , point_expression )
    (14) translation -> . ROTATE ( animation_param , expression , AROUND ( point_expression ) )

    PRINT           shift and go to state 10
    IDENTIFIER      shift and go to state 11
    FOR             shift and go to state 12
    CIRCLE          shift and go to state 17
    RECT            shift and go to state 18
    POLYGON         shift and go to state 19
    TRANSLATE       shift and go to state 20
    ROTATE          shift and go to state 21

    subprogram                     shift and go to state 114
    statement                      shift and go to state 3
    assignation                    shift and go to state 4
    assignation_shape              shift and go to state 5
    assignation_color              shift and go to state 6
    structure                      shift and go to state 7
    shape                          shift and go to state 8
    animation                      shift and go to state 9
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14
    polygon_g                      shift and go to state 15
    translation                    shift and go to state 16

state 110

    (20) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , . color_expression }
    (27) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 45

    color_expression               shift and go to state 115

state 111

    (26) size_expression -> SIZE ( expression , expression . )
    (28) expression -> expression . ADD_OP expression
    (29) expression -> expression . MUL_OP expression

    )               shift and go to state 116
    ADD_OP          shift and go to state 37
    MUL_OP          shift and go to state 38


state 112

    (14) translation -> ROTATE ( animation_param , expression , AROUND ( point_expression . ) )

    )               shift and go to state 117


state 113

    (27) color_expression -> COLOR ( expression , expression , expression ) .

    ;               reduce using rule 27 (color_expression -> COLOR ( expression , expression , expression ) .)
    }               reduce using rule 27 (color_expression -> COLOR ( expression , expression , expression ) .)


state 114

    (11) structure -> FOR ( expression , expression , expression ) { subprogram . }

    }               shift and go to state 118


state 115

    (20) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression . }

    }               shift and go to state 119


state 116

    (26) size_expression -> SIZE ( expression , expression ) .

    ,               reduce using rule 26 (size_expression -> SIZE ( expression , expression ) .)


state 117

    (14) translation -> ROTATE ( animation_param , expression , AROUND ( point_expression ) . )

    )               shift and go to state 120


state 118

    (11) structure -> FOR ( expression , expression , expression ) { subprogram } .

    ;               reduce using rule 11 (structure -> FOR ( expression , expression , expression ) { subprogram } .)


state 119

    (20) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .

    ;               reduce using rule 20 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)
    ,               reduce using rule 20 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)


state 120

    (14) translation -> ROTATE ( animation_param , expression , AROUND ( point_expression ) ) .

    ;               reduce using rule 14 (translation -> ROTATE ( animation_param , expression , AROUND ( point_expression ) ) .)

