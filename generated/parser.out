Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> subprogram
Rule 2     subprogram -> statement ;
Rule 3     subprogram -> statement ; subprogram
Rule 4     statement -> assignation
Rule 5     statement -> assignation_shape
Rule 6     statement -> structure
Rule 7     statement -> shape
Rule 8     statement -> animation
Rule 9     statement -> PRINT expression
Rule 10    structure -> FOR ( expression , expression , expression ) { subprogram }
Rule 11    animation -> translation
Rule 12    translation -> TRANSLATE ( animation_param , point_expression )
Rule 13    translation -> ROTATE ( animation_param , expression )
Rule 14    animation_param -> IDENTIFIER
Rule 15    animation_param -> shape
Rule 16    shape -> circle_g
Rule 17    shape -> rect_g
Rule 18    circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
Rule 19    rect_g -> RECT { point_expression , size_expression , color_expression }
Rule 20    point_expression -> POINT ( expression , expression )
Rule 21    size_expression -> SIZE ( expression , expression )
Rule 22    color_expression -> COLOR ( expression , expression , expression )
Rule 23    expression -> expression ADD_OP expression
Rule 24    expression -> expression MUL_OP expression
Rule 25    expression -> NUMBER
Rule 26    expression -> IDENTIFIER
Rule 27    expression -> ( expression )
Rule 28    expression -> ADD_OP expression
Rule 29    assignation_shape -> IDENTIFIER = shape
Rule 30    assignation -> IDENTIFIER = expression

Terminals, with rules where they appear

(                    : 10 12 13 18 20 21 22 27
)                    : 10 12 13 18 20 21 22 27
,                    : 10 10 12 13 18 18 19 19 20 21 22 22
;                    : 2 3
=                    : 29 30
ADD_OP               : 23 28
CIRCLE               : 18
COLOR                : 22
FOR                  : 10
IDENTIFIER           : 14 26 29 30
MUL_OP               : 24
NUMBER               : 25
POINT                : 20
PRINT                : 9
RADIUS               : 18
RECT                 : 19
ROTATE               : 13
SIZE                 : 21
TRANSLATE            : 12
error                : 
{                    : 10 18 19
}                    : 10 18 19

Nonterminals, with rules where they appear

animation            : 8
animation_param      : 12 13
assignation          : 4
assignation_shape    : 5
circle_g             : 16
color_expression     : 18 19
expression           : 9 10 10 10 13 18 20 20 21 21 22 22 22 23 23 24 24 27 28 30
point_expression     : 12 18 19
program              : 0
rect_g               : 17
shape                : 7 15 29
size_expression      : 19
statement            : 2 3
structure            : 6
subprogram           : 1 3 10
translation          : 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . subprogram
    (2) subprogram -> . statement ;
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . assignation_shape
    (6) statement -> . structure
    (7) statement -> . shape
    (8) statement -> . animation
    (9) statement -> . PRINT expression
    (30) assignation -> . IDENTIFIER = expression
    (29) assignation_shape -> . IDENTIFIER = shape
    (10) structure -> . FOR ( expression , expression , expression ) { subprogram }
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (11) animation -> . translation
    (18) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (19) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (12) translation -> . TRANSLATE ( animation_param , point_expression )
    (13) translation -> . ROTATE ( animation_param , expression )

    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 10
    FOR             shift and go to state 11
    CIRCLE          shift and go to state 15
    RECT            shift and go to state 16
    TRANSLATE       shift and go to state 17
    ROTATE          shift and go to state 18

    program                        shift and go to state 1
    subprogram                     shift and go to state 2
    statement                      shift and go to state 3
    assignation                    shift and go to state 4
    assignation_shape              shift and go to state 5
    structure                      shift and go to state 6
    shape                          shift and go to state 7
    animation                      shift and go to state 8
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13
    translation                    shift and go to state 14

state 1

    (0) S' -> program .



state 2

    (1) program -> subprogram .

    $end            reduce using rule 1 (program -> subprogram .)


state 3

    (2) subprogram -> statement . ;
    (3) subprogram -> statement . ; subprogram

    ;               shift and go to state 19


state 4

    (4) statement -> assignation .

    ;               reduce using rule 4 (statement -> assignation .)


state 5

    (5) statement -> assignation_shape .

    ;               reduce using rule 5 (statement -> assignation_shape .)


state 6

    (6) statement -> structure .

    ;               reduce using rule 6 (statement -> structure .)


state 7

    (7) statement -> shape .

    ;               reduce using rule 7 (statement -> shape .)


state 8

    (8) statement -> animation .

    ;               reduce using rule 8 (statement -> animation .)


state 9

    (9) statement -> PRINT . expression
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 20

state 10

    (30) assignation -> IDENTIFIER . = expression
    (29) assignation_shape -> IDENTIFIER . = shape

    =               shift and go to state 25


state 11

    (10) structure -> FOR . ( expression , expression , expression ) { subprogram }

    (               shift and go to state 26


state 12

    (16) shape -> circle_g .

    ;               reduce using rule 16 (shape -> circle_g .)
    ,               reduce using rule 16 (shape -> circle_g .)


state 13

    (17) shape -> rect_g .

    ;               reduce using rule 17 (shape -> rect_g .)
    ,               reduce using rule 17 (shape -> rect_g .)


state 14

    (11) animation -> translation .

    ;               reduce using rule 11 (animation -> translation .)


state 15

    (18) circle_g -> CIRCLE . { point_expression , RADIUS ( expression ) , color_expression }

    {               shift and go to state 27


state 16

    (19) rect_g -> RECT . { point_expression , size_expression , color_expression }

    {               shift and go to state 28


state 17

    (12) translation -> TRANSLATE . ( animation_param , point_expression )

    (               shift and go to state 29


state 18

    (13) translation -> ROTATE . ( animation_param , expression )

    (               shift and go to state 30


state 19

    (2) subprogram -> statement ; .
    (3) subprogram -> statement ; . subprogram
    (2) subprogram -> . statement ;
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . assignation_shape
    (6) statement -> . structure
    (7) statement -> . shape
    (8) statement -> . animation
    (9) statement -> . PRINT expression
    (30) assignation -> . IDENTIFIER = expression
    (29) assignation_shape -> . IDENTIFIER = shape
    (10) structure -> . FOR ( expression , expression , expression ) { subprogram }
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (11) animation -> . translation
    (18) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (19) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (12) translation -> . TRANSLATE ( animation_param , point_expression )
    (13) translation -> . ROTATE ( animation_param , expression )

    $end            reduce using rule 2 (subprogram -> statement ; .)
    }               reduce using rule 2 (subprogram -> statement ; .)
    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 10
    FOR             shift and go to state 11
    CIRCLE          shift and go to state 15
    RECT            shift and go to state 16
    TRANSLATE       shift and go to state 17
    ROTATE          shift and go to state 18

    statement                      shift and go to state 3
    subprogram                     shift and go to state 31
    assignation                    shift and go to state 4
    assignation_shape              shift and go to state 5
    structure                      shift and go to state 6
    shape                          shift and go to state 7
    animation                      shift and go to state 8
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13
    translation                    shift and go to state 14

state 20

    (9) statement -> PRINT expression .
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ;               reduce using rule 9 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 21

    (28) expression -> ADD_OP . expression
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 34

state 22

    (25) expression -> NUMBER .

    ADD_OP          reduce using rule 25 (expression -> NUMBER .)
    MUL_OP          reduce using rule 25 (expression -> NUMBER .)
    ;               reduce using rule 25 (expression -> NUMBER .)
    )               reduce using rule 25 (expression -> NUMBER .)
    ,               reduce using rule 25 (expression -> NUMBER .)


state 23

    (26) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 26 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 26 (expression -> IDENTIFIER .)
    ;               reduce using rule 26 (expression -> IDENTIFIER .)
    )               reduce using rule 26 (expression -> IDENTIFIER .)
    ,               reduce using rule 26 (expression -> IDENTIFIER .)


state 24

    (27) expression -> ( . expression )
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 35

state 25

    (30) assignation -> IDENTIFIER = . expression
    (29) assignation_shape -> IDENTIFIER = . shape
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (18) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (19) rect_g -> . RECT { point_expression , size_expression , color_expression }

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21
    CIRCLE          shift and go to state 15
    RECT            shift and go to state 16

    expression                     shift and go to state 36
    shape                          shift and go to state 37
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13

state 26

    (10) structure -> FOR ( . expression , expression , expression ) { subprogram }
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 38

state 27

    (18) circle_g -> CIRCLE { . point_expression , RADIUS ( expression ) , color_expression }
    (20) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 40

    point_expression               shift and go to state 39

state 28

    (19) rect_g -> RECT { . point_expression , size_expression , color_expression }
    (20) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 40

    point_expression               shift and go to state 41

state 29

    (12) translation -> TRANSLATE ( . animation_param , point_expression )
    (14) animation_param -> . IDENTIFIER
    (15) animation_param -> . shape
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (18) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (19) rect_g -> . RECT { point_expression , size_expression , color_expression }

    IDENTIFIER      shift and go to state 43
    CIRCLE          shift and go to state 15
    RECT            shift and go to state 16

    animation_param                shift and go to state 42
    shape                          shift and go to state 44
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13

state 30

    (13) translation -> ROTATE ( . animation_param , expression )
    (14) animation_param -> . IDENTIFIER
    (15) animation_param -> . shape
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (18) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (19) rect_g -> . RECT { point_expression , size_expression , color_expression }

    IDENTIFIER      shift and go to state 43
    CIRCLE          shift and go to state 15
    RECT            shift and go to state 16

    animation_param                shift and go to state 45
    shape                          shift and go to state 44
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13

state 31

    (3) subprogram -> statement ; subprogram .

    $end            reduce using rule 3 (subprogram -> statement ; subprogram .)
    }               reduce using rule 3 (subprogram -> statement ; subprogram .)


state 32

    (23) expression -> expression ADD_OP . expression
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 46

state 33

    (24) expression -> expression MUL_OP . expression
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 47

state 34

    (28) expression -> ADD_OP expression .
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 28 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 28 (expression -> ADD_OP expression .)
    ;               reduce using rule 28 (expression -> ADD_OP expression .)
    )               reduce using rule 28 (expression -> ADD_OP expression .)
    ,               reduce using rule 28 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 32 ]
  ! MUL_OP          [ shift and go to state 33 ]


state 35

    (27) expression -> ( expression . )
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    )               shift and go to state 48
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 36

    (30) assignation -> IDENTIFIER = expression .
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ;               reduce using rule 30 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 37

    (29) assignation_shape -> IDENTIFIER = shape .

    ;               reduce using rule 29 (assignation_shape -> IDENTIFIER = shape .)


state 38

    (10) structure -> FOR ( expression . , expression , expression ) { subprogram }
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ,               shift and go to state 49
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 39

    (18) circle_g -> CIRCLE { point_expression . , RADIUS ( expression ) , color_expression }

    ,               shift and go to state 50


state 40

    (20) point_expression -> POINT . ( expression , expression )

    (               shift and go to state 51


state 41

    (19) rect_g -> RECT { point_expression . , size_expression , color_expression }

    ,               shift and go to state 52


state 42

    (12) translation -> TRANSLATE ( animation_param . , point_expression )

    ,               shift and go to state 53


state 43

    (14) animation_param -> IDENTIFIER .

    ,               reduce using rule 14 (animation_param -> IDENTIFIER .)


state 44

    (15) animation_param -> shape .

    ,               reduce using rule 15 (animation_param -> shape .)


state 45

    (13) translation -> ROTATE ( animation_param . , expression )

    ,               shift and go to state 54


state 46

    (23) expression -> expression ADD_OP expression .
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 23 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 23 (expression -> expression ADD_OP expression .)
    )               reduce using rule 23 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 23 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 33

  ! MUL_OP          [ reduce using rule 23 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 32 ]


state 47

    (24) expression -> expression MUL_OP expression .
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 24 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 24 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 24 (expression -> expression MUL_OP expression .)
    )               reduce using rule 24 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 24 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 32 ]
  ! MUL_OP          [ shift and go to state 33 ]


state 48

    (27) expression -> ( expression ) .

    ADD_OP          reduce using rule 27 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 27 (expression -> ( expression ) .)
    ;               reduce using rule 27 (expression -> ( expression ) .)
    )               reduce using rule 27 (expression -> ( expression ) .)
    ,               reduce using rule 27 (expression -> ( expression ) .)


state 49

    (10) structure -> FOR ( expression , . expression , expression ) { subprogram }
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 55

state 50

    (18) circle_g -> CIRCLE { point_expression , . RADIUS ( expression ) , color_expression }

    RADIUS          shift and go to state 56


state 51

    (20) point_expression -> POINT ( . expression , expression )
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 57

state 52

    (19) rect_g -> RECT { point_expression , . size_expression , color_expression }
    (21) size_expression -> . SIZE ( expression , expression )

    SIZE            shift and go to state 59

    size_expression                shift and go to state 58

state 53

    (12) translation -> TRANSLATE ( animation_param , . point_expression )
    (20) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 40

    point_expression               shift and go to state 60

state 54

    (13) translation -> ROTATE ( animation_param , . expression )
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 61

state 55

    (10) structure -> FOR ( expression , expression . , expression ) { subprogram }
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ,               shift and go to state 62
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 56

    (18) circle_g -> CIRCLE { point_expression , RADIUS . ( expression ) , color_expression }

    (               shift and go to state 63


state 57

    (20) point_expression -> POINT ( expression . , expression )
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ,               shift and go to state 64
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 58

    (19) rect_g -> RECT { point_expression , size_expression . , color_expression }

    ,               shift and go to state 65


state 59

    (21) size_expression -> SIZE . ( expression , expression )

    (               shift and go to state 66


state 60

    (12) translation -> TRANSLATE ( animation_param , point_expression . )

    )               shift and go to state 67


state 61

    (13) translation -> ROTATE ( animation_param , expression . )
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    )               shift and go to state 68
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 62

    (10) structure -> FOR ( expression , expression , . expression ) { subprogram }
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 69

state 63

    (18) circle_g -> CIRCLE { point_expression , RADIUS ( . expression ) , color_expression }
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 70

state 64

    (20) point_expression -> POINT ( expression , . expression )
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 71

state 65

    (19) rect_g -> RECT { point_expression , size_expression , . color_expression }
    (22) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 73

    color_expression               shift and go to state 72

state 66

    (21) size_expression -> SIZE ( . expression , expression )
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 74

state 67

    (12) translation -> TRANSLATE ( animation_param , point_expression ) .

    ;               reduce using rule 12 (translation -> TRANSLATE ( animation_param , point_expression ) .)


state 68

    (13) translation -> ROTATE ( animation_param , expression ) .

    ;               reduce using rule 13 (translation -> ROTATE ( animation_param , expression ) .)


state 69

    (10) structure -> FOR ( expression , expression , expression . ) { subprogram }
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    )               shift and go to state 75
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 70

    (18) circle_g -> CIRCLE { point_expression , RADIUS ( expression . ) , color_expression }
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    )               shift and go to state 76
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 71

    (20) point_expression -> POINT ( expression , expression . )
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    )               shift and go to state 77
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 72

    (19) rect_g -> RECT { point_expression , size_expression , color_expression . }

    }               shift and go to state 78


state 73

    (22) color_expression -> COLOR . ( expression , expression , expression )

    (               shift and go to state 79


state 74

    (21) size_expression -> SIZE ( expression . , expression )
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ,               shift and go to state 80
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 75

    (10) structure -> FOR ( expression , expression , expression ) . { subprogram }

    {               shift and go to state 81


state 76

    (18) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) . , color_expression }

    ,               shift and go to state 82


state 77

    (20) point_expression -> POINT ( expression , expression ) .

    ,               reduce using rule 20 (point_expression -> POINT ( expression , expression ) .)
    )               reduce using rule 20 (point_expression -> POINT ( expression , expression ) .)


state 78

    (19) rect_g -> RECT { point_expression , size_expression , color_expression } .

    ;               reduce using rule 19 (rect_g -> RECT { point_expression , size_expression , color_expression } .)
    ,               reduce using rule 19 (rect_g -> RECT { point_expression , size_expression , color_expression } .)


state 79

    (22) color_expression -> COLOR ( . expression , expression , expression )
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 83

state 80

    (21) size_expression -> SIZE ( expression , . expression )
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 84

state 81

    (10) structure -> FOR ( expression , expression , expression ) { . subprogram }
    (2) subprogram -> . statement ;
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . assignation_shape
    (6) statement -> . structure
    (7) statement -> . shape
    (8) statement -> . animation
    (9) statement -> . PRINT expression
    (30) assignation -> . IDENTIFIER = expression
    (29) assignation_shape -> . IDENTIFIER = shape
    (10) structure -> . FOR ( expression , expression , expression ) { subprogram }
    (16) shape -> . circle_g
    (17) shape -> . rect_g
    (11) animation -> . translation
    (18) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (19) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (12) translation -> . TRANSLATE ( animation_param , point_expression )
    (13) translation -> . ROTATE ( animation_param , expression )

    PRINT           shift and go to state 9
    IDENTIFIER      shift and go to state 10
    FOR             shift and go to state 11
    CIRCLE          shift and go to state 15
    RECT            shift and go to state 16
    TRANSLATE       shift and go to state 17
    ROTATE          shift and go to state 18

    subprogram                     shift and go to state 85
    statement                      shift and go to state 3
    assignation                    shift and go to state 4
    assignation_shape              shift and go to state 5
    structure                      shift and go to state 6
    shape                          shift and go to state 7
    animation                      shift and go to state 8
    circle_g                       shift and go to state 12
    rect_g                         shift and go to state 13
    translation                    shift and go to state 14

state 82

    (18) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , . color_expression }
    (22) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 73

    color_expression               shift and go to state 86

state 83

    (22) color_expression -> COLOR ( expression . , expression , expression )
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ,               shift and go to state 87
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 84

    (21) size_expression -> SIZE ( expression , expression . )
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    )               shift and go to state 88
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 85

    (10) structure -> FOR ( expression , expression , expression ) { subprogram . }

    }               shift and go to state 89


state 86

    (18) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression . }

    }               shift and go to state 90


state 87

    (22) color_expression -> COLOR ( expression , . expression , expression )
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 91

state 88

    (21) size_expression -> SIZE ( expression , expression ) .

    ,               reduce using rule 21 (size_expression -> SIZE ( expression , expression ) .)


state 89

    (10) structure -> FOR ( expression , expression , expression ) { subprogram } .

    ;               reduce using rule 10 (structure -> FOR ( expression , expression , expression ) { subprogram } .)


state 90

    (18) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .

    ;               reduce using rule 18 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)
    ,               reduce using rule 18 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)


state 91

    (22) color_expression -> COLOR ( expression , expression . , expression )
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    ,               shift and go to state 92
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 92

    (22) color_expression -> COLOR ( expression , expression , . expression )
    (23) expression -> . expression ADD_OP expression
    (24) expression -> . expression MUL_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    (               shift and go to state 24
    ADD_OP          shift and go to state 21

    expression                     shift and go to state 93

state 93

    (22) color_expression -> COLOR ( expression , expression , expression . )
    (23) expression -> expression . ADD_OP expression
    (24) expression -> expression . MUL_OP expression

    )               shift and go to state 94
    ADD_OP          shift and go to state 32
    MUL_OP          shift and go to state 33


state 94

    (22) color_expression -> COLOR ( expression , expression , expression ) .

    }               reduce using rule 22 (color_expression -> COLOR ( expression , expression , expression ) .)

