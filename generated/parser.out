Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> subprogram
Rule 2     subprogram -> statement
Rule 3     subprogram -> statement ; subprogram
Rule 4     statement -> assignation
Rule 5     statement -> structure
Rule 6     statement -> shape
Rule 7     statement -> animation
Rule 8     statement -> PRINT expression
Rule 9     structure -> WHILE expression { subprogram }
Rule 10    animation -> translation
Rule 11    translation -> TRANSLATE ( IDENTIFIER , point_expression )
Rule 12    translation -> ROTATE ( IDENTIFIER , expression )
Rule 13    shape -> circle_g
Rule 14    shape -> rect_g
Rule 15    shape -> polygon_g
Rule 16    circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
Rule 17    rect_g -> RECT { point_expression , size_expression , color_expression }
Rule 18    polygon_g -> POLYGON { ( points_expression ) , color_expression }
Rule 19    points_expression -> point_expression
Rule 20    points_expression -> point_expression , points_expression
Rule 21    point_expression -> POINT ( expression , expression )
Rule 22    size_expression -> SIZE ( expression , expression )
Rule 23    color_expression -> COLOR ( expression , expression , expression )
Rule 24    expression -> expression ADD_OP expression
Rule 25    expression -> expression MUL_OP expression
Rule 26    expression -> NUMBER
Rule 27    expression -> IDENTIFIER
Rule 28    expression -> ( expression )
Rule 29    expression -> ADD_OP expression
Rule 30    assignation -> IDENTIFIER = assign_expression
Rule 31    assign_expression -> expression
Rule 32    assign_expression -> shape

Terminals, with rules where they appear

(                    : 11 12 16 18 21 22 23 28
)                    : 11 12 16 18 21 22 23 28
,                    : 11 12 16 16 17 17 18 20 21 22 23 23
;                    : 3
=                    : 30
ADD_OP               : 24 29
CIRCLE               : 16
COLOR                : 23
IDENTIFIER           : 11 12 27 30
MUL_OP               : 25
NUMBER               : 26
POINT                : 21
POLYGON              : 18
PRINT                : 8
RADIUS               : 16
RECT                 : 17
ROTATE               : 12
SIZE                 : 22
TRANSLATE            : 11
WHILE                : 9
error                : 
{                    : 9 16 17 18
}                    : 9 16 17 18

Nonterminals, with rules where they appear

animation            : 7
assign_expression    : 30
assignation          : 4
circle_g             : 13
color_expression     : 16 17 18
expression           : 8 9 12 16 21 21 22 22 23 23 23 24 24 25 25 28 29 31
point_expression     : 11 16 17 19 20
points_expression    : 18 20
polygon_g            : 15
program              : 0
rect_g               : 14
shape                : 6 32
size_expression      : 17
statement            : 2 3
structure            : 5
subprogram           : 1 3 9
translation          : 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . subprogram
    (2) subprogram -> . statement
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . shape
    (7) statement -> . animation
    (8) statement -> . PRINT expression
    (30) assignation -> . IDENTIFIER = assign_expression
    (9) structure -> . WHILE expression { subprogram }
    (13) shape -> . circle_g
    (14) shape -> . rect_g
    (15) shape -> . polygon_g
    (10) animation -> . translation
    (16) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (17) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (18) polygon_g -> . POLYGON { ( points_expression ) , color_expression }
    (11) translation -> . TRANSLATE ( IDENTIFIER , point_expression )
    (12) translation -> . ROTATE ( IDENTIFIER , expression )

    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 11
    WHILE           shift and go to state 1
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 4
    POLYGON         shift and go to state 5
    TRANSLATE       shift and go to state 9
    ROTATE          shift and go to state 10

    program                        shift and go to state 2
    subprogram                     shift and go to state 3
    animation                      shift and go to state 18
    shape                          shift and go to state 12
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14
    statement                      shift and go to state 6
    polygon_g                      shift and go to state 7
    structure                      shift and go to state 17
    translation                    shift and go to state 8
    assignation                    shift and go to state 19

state 1

    (9) structure -> WHILE . expression { subprogram }
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 23

state 2

    (0) S' -> program .



state 3

    (1) program -> subprogram .

    $end            reduce using rule 1 (program -> subprogram .)


state 4

    (17) rect_g -> RECT . { point_expression , size_expression , color_expression }

    {               shift and go to state 25


state 5

    (18) polygon_g -> POLYGON . { ( points_expression ) , color_expression }

    {               shift and go to state 26


state 6

    (2) subprogram -> statement .
    (3) subprogram -> statement . ; subprogram

    }               reduce using rule 2 (subprogram -> statement .)
    $end            reduce using rule 2 (subprogram -> statement .)
    ;               shift and go to state 27


state 7

    (15) shape -> polygon_g .

    ;               reduce using rule 15 (shape -> polygon_g .)
    $end            reduce using rule 15 (shape -> polygon_g .)
    }               reduce using rule 15 (shape -> polygon_g .)


state 8

    (10) animation -> translation .

    ;               reduce using rule 10 (animation -> translation .)
    $end            reduce using rule 10 (animation -> translation .)
    }               reduce using rule 10 (animation -> translation .)


state 9

    (11) translation -> TRANSLATE . ( IDENTIFIER , point_expression )

    (               shift and go to state 28


state 10

    (12) translation -> ROTATE . ( IDENTIFIER , expression )

    (               shift and go to state 29


state 11

    (30) assignation -> IDENTIFIER . = assign_expression

    =               shift and go to state 30


state 12

    (6) statement -> shape .

    ;               reduce using rule 6 (statement -> shape .)
    $end            reduce using rule 6 (statement -> shape .)
    }               reduce using rule 6 (statement -> shape .)


state 13

    (13) shape -> circle_g .

    ;               reduce using rule 13 (shape -> circle_g .)
    $end            reduce using rule 13 (shape -> circle_g .)
    }               reduce using rule 13 (shape -> circle_g .)


state 14

    (14) shape -> rect_g .

    ;               reduce using rule 14 (shape -> rect_g .)
    $end            reduce using rule 14 (shape -> rect_g .)
    }               reduce using rule 14 (shape -> rect_g .)


state 15

    (8) statement -> PRINT . expression
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 31

state 16

    (16) circle_g -> CIRCLE . { point_expression , RADIUS ( expression ) , color_expression }

    {               shift and go to state 32


state 17

    (5) statement -> structure .

    ;               reduce using rule 5 (statement -> structure .)
    $end            reduce using rule 5 (statement -> structure .)
    }               reduce using rule 5 (statement -> structure .)


state 18

    (7) statement -> animation .

    ;               reduce using rule 7 (statement -> animation .)
    $end            reduce using rule 7 (statement -> animation .)
    }               reduce using rule 7 (statement -> animation .)


state 19

    (4) statement -> assignation .

    ;               reduce using rule 4 (statement -> assignation .)
    $end            reduce using rule 4 (statement -> assignation .)
    }               reduce using rule 4 (statement -> assignation .)


state 20

    (26) expression -> NUMBER .

    ADD_OP          reduce using rule 26 (expression -> NUMBER .)
    MUL_OP          reduce using rule 26 (expression -> NUMBER .)
    {               reduce using rule 26 (expression -> NUMBER .)
    ;               reduce using rule 26 (expression -> NUMBER .)
    $end            reduce using rule 26 (expression -> NUMBER .)
    }               reduce using rule 26 (expression -> NUMBER .)
    )               reduce using rule 26 (expression -> NUMBER .)
    ,               reduce using rule 26 (expression -> NUMBER .)


state 21

    (28) expression -> ( . expression )
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 33

state 22

    (27) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 27 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 27 (expression -> IDENTIFIER .)
    {               reduce using rule 27 (expression -> IDENTIFIER .)
    ;               reduce using rule 27 (expression -> IDENTIFIER .)
    $end            reduce using rule 27 (expression -> IDENTIFIER .)
    }               reduce using rule 27 (expression -> IDENTIFIER .)
    )               reduce using rule 27 (expression -> IDENTIFIER .)
    ,               reduce using rule 27 (expression -> IDENTIFIER .)


state 23

    (9) structure -> WHILE expression . { subprogram }
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    {               shift and go to state 34
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 24

    (29) expression -> ADD_OP . expression
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 37

state 25

    (17) rect_g -> RECT { . point_expression , size_expression , color_expression }
    (21) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 39

    point_expression               shift and go to state 38

state 26

    (18) polygon_g -> POLYGON { . ( points_expression ) , color_expression }

    (               shift and go to state 40


state 27

    (3) subprogram -> statement ; . subprogram
    (2) subprogram -> . statement
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . shape
    (7) statement -> . animation
    (8) statement -> . PRINT expression
    (30) assignation -> . IDENTIFIER = assign_expression
    (9) structure -> . WHILE expression { subprogram }
    (13) shape -> . circle_g
    (14) shape -> . rect_g
    (15) shape -> . polygon_g
    (10) animation -> . translation
    (16) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (17) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (18) polygon_g -> . POLYGON { ( points_expression ) , color_expression }
    (11) translation -> . TRANSLATE ( IDENTIFIER , point_expression )
    (12) translation -> . ROTATE ( IDENTIFIER , expression )

    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 11
    WHILE           shift and go to state 1
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 4
    POLYGON         shift and go to state 5
    TRANSLATE       shift and go to state 9
    ROTATE          shift and go to state 10

    subprogram                     shift and go to state 41
    animation                      shift and go to state 18
    shape                          shift and go to state 12
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14
    statement                      shift and go to state 6
    structure                      shift and go to state 17
    polygon_g                      shift and go to state 7
    translation                    shift and go to state 8
    assignation                    shift and go to state 19

state 28

    (11) translation -> TRANSLATE ( . IDENTIFIER , point_expression )

    IDENTIFIER      shift and go to state 42


state 29

    (12) translation -> ROTATE ( . IDENTIFIER , expression )

    IDENTIFIER      shift and go to state 43


state 30

    (30) assignation -> IDENTIFIER = . assign_expression
    (31) assign_expression -> . expression
    (32) assign_expression -> . shape
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression
    (13) shape -> . circle_g
    (14) shape -> . rect_g
    (15) shape -> . polygon_g
    (16) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (17) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (18) polygon_g -> . POLYGON { ( points_expression ) , color_expression }

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 4
    POLYGON         shift and go to state 5

    polygon_g                      shift and go to state 7
    expression                     shift and go to state 45
    assign_expression              shift and go to state 44
    shape                          shift and go to state 46
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14

state 31

    (8) statement -> PRINT expression .
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    ;               reduce using rule 8 (statement -> PRINT expression .)
    $end            reduce using rule 8 (statement -> PRINT expression .)
    }               reduce using rule 8 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 32

    (16) circle_g -> CIRCLE { . point_expression , RADIUS ( expression ) , color_expression }
    (21) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 39

    point_expression               shift and go to state 47

state 33

    (28) expression -> ( expression . )
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    )               shift and go to state 48
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 34

    (9) structure -> WHILE expression { . subprogram }
    (2) subprogram -> . statement
    (3) subprogram -> . statement ; subprogram
    (4) statement -> . assignation
    (5) statement -> . structure
    (6) statement -> . shape
    (7) statement -> . animation
    (8) statement -> . PRINT expression
    (30) assignation -> . IDENTIFIER = assign_expression
    (9) structure -> . WHILE expression { subprogram }
    (13) shape -> . circle_g
    (14) shape -> . rect_g
    (15) shape -> . polygon_g
    (10) animation -> . translation
    (16) circle_g -> . CIRCLE { point_expression , RADIUS ( expression ) , color_expression }
    (17) rect_g -> . RECT { point_expression , size_expression , color_expression }
    (18) polygon_g -> . POLYGON { ( points_expression ) , color_expression }
    (11) translation -> . TRANSLATE ( IDENTIFIER , point_expression )
    (12) translation -> . ROTATE ( IDENTIFIER , expression )

    PRINT           shift and go to state 15
    IDENTIFIER      shift and go to state 11
    WHILE           shift and go to state 1
    CIRCLE          shift and go to state 16
    RECT            shift and go to state 4
    POLYGON         shift and go to state 5
    TRANSLATE       shift and go to state 9
    ROTATE          shift and go to state 10

    subprogram                     shift and go to state 49
    structure                      shift and go to state 17
    shape                          shift and go to state 12
    circle_g                       shift and go to state 13
    rect_g                         shift and go to state 14
    statement                      shift and go to state 6
    animation                      shift and go to state 18
    polygon_g                      shift and go to state 7
    translation                    shift and go to state 8
    assignation                    shift and go to state 19

state 35

    (24) expression -> expression ADD_OP . expression
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 50

state 36

    (25) expression -> expression MUL_OP . expression
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 51

state 37

    (29) expression -> ADD_OP expression .
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 29 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 29 (expression -> ADD_OP expression .)
    {               reduce using rule 29 (expression -> ADD_OP expression .)
    ;               reduce using rule 29 (expression -> ADD_OP expression .)
    $end            reduce using rule 29 (expression -> ADD_OP expression .)
    }               reduce using rule 29 (expression -> ADD_OP expression .)
    )               reduce using rule 29 (expression -> ADD_OP expression .)
    ,               reduce using rule 29 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 35 ]
  ! MUL_OP          [ shift and go to state 36 ]


state 38

    (17) rect_g -> RECT { point_expression . , size_expression , color_expression }

    ,               shift and go to state 52


state 39

    (21) point_expression -> POINT . ( expression , expression )

    (               shift and go to state 53


state 40

    (18) polygon_g -> POLYGON { ( . points_expression ) , color_expression }
    (19) points_expression -> . point_expression
    (20) points_expression -> . point_expression , points_expression
    (21) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 39

    points_expression              shift and go to state 54
    point_expression               shift and go to state 55

state 41

    (3) subprogram -> statement ; subprogram .

    }               reduce using rule 3 (subprogram -> statement ; subprogram .)
    $end            reduce using rule 3 (subprogram -> statement ; subprogram .)


state 42

    (11) translation -> TRANSLATE ( IDENTIFIER . , point_expression )

    ,               shift and go to state 56


state 43

    (12) translation -> ROTATE ( IDENTIFIER . , expression )

    ,               shift and go to state 57


state 44

    (30) assignation -> IDENTIFIER = assign_expression .

    ;               reduce using rule 30 (assignation -> IDENTIFIER = assign_expression .)
    $end            reduce using rule 30 (assignation -> IDENTIFIER = assign_expression .)
    }               reduce using rule 30 (assignation -> IDENTIFIER = assign_expression .)


state 45

    (31) assign_expression -> expression .
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    ;               reduce using rule 31 (assign_expression -> expression .)
    $end            reduce using rule 31 (assign_expression -> expression .)
    }               reduce using rule 31 (assign_expression -> expression .)
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 46

    (32) assign_expression -> shape .

    ;               reduce using rule 32 (assign_expression -> shape .)
    $end            reduce using rule 32 (assign_expression -> shape .)
    }               reduce using rule 32 (assign_expression -> shape .)


state 47

    (16) circle_g -> CIRCLE { point_expression . , RADIUS ( expression ) , color_expression }

    ,               shift and go to state 58


state 48

    (28) expression -> ( expression ) .

    ADD_OP          reduce using rule 28 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 28 (expression -> ( expression ) .)
    {               reduce using rule 28 (expression -> ( expression ) .)
    ;               reduce using rule 28 (expression -> ( expression ) .)
    $end            reduce using rule 28 (expression -> ( expression ) .)
    }               reduce using rule 28 (expression -> ( expression ) .)
    )               reduce using rule 28 (expression -> ( expression ) .)
    ,               reduce using rule 28 (expression -> ( expression ) .)


state 49

    (9) structure -> WHILE expression { subprogram . }

    }               shift and go to state 59


state 50

    (24) expression -> expression ADD_OP expression .
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 24 (expression -> expression ADD_OP expression .)
    {               reduce using rule 24 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 24 (expression -> expression ADD_OP expression .)
    $end            reduce using rule 24 (expression -> expression ADD_OP expression .)
    }               reduce using rule 24 (expression -> expression ADD_OP expression .)
    )               reduce using rule 24 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 24 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 36

  ! MUL_OP          [ reduce using rule 24 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 35 ]


state 51

    (25) expression -> expression MUL_OP expression .
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    ADD_OP          reduce using rule 25 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 25 (expression -> expression MUL_OP expression .)
    {               reduce using rule 25 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 25 (expression -> expression MUL_OP expression .)
    $end            reduce using rule 25 (expression -> expression MUL_OP expression .)
    }               reduce using rule 25 (expression -> expression MUL_OP expression .)
    )               reduce using rule 25 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 25 (expression -> expression MUL_OP expression .)

  ! ADD_OP          [ shift and go to state 35 ]
  ! MUL_OP          [ shift and go to state 36 ]


state 52

    (17) rect_g -> RECT { point_expression , . size_expression , color_expression }
    (22) size_expression -> . SIZE ( expression , expression )

    SIZE            shift and go to state 61

    size_expression                shift and go to state 60

state 53

    (21) point_expression -> POINT ( . expression , expression )
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 62

state 54

    (18) polygon_g -> POLYGON { ( points_expression . ) , color_expression }

    )               shift and go to state 63


state 55

    (19) points_expression -> point_expression .
    (20) points_expression -> point_expression . , points_expression

    )               reduce using rule 19 (points_expression -> point_expression .)
    ,               shift and go to state 64


state 56

    (11) translation -> TRANSLATE ( IDENTIFIER , . point_expression )
    (21) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 39

    point_expression               shift and go to state 65

state 57

    (12) translation -> ROTATE ( IDENTIFIER , . expression )
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 66

state 58

    (16) circle_g -> CIRCLE { point_expression , . RADIUS ( expression ) , color_expression }

    RADIUS          shift and go to state 67


state 59

    (9) structure -> WHILE expression { subprogram } .

    ;               reduce using rule 9 (structure -> WHILE expression { subprogram } .)
    }               reduce using rule 9 (structure -> WHILE expression { subprogram } .)
    $end            reduce using rule 9 (structure -> WHILE expression { subprogram } .)


state 60

    (17) rect_g -> RECT { point_expression , size_expression . , color_expression }

    ,               shift and go to state 68


state 61

    (22) size_expression -> SIZE . ( expression , expression )

    (               shift and go to state 69


state 62

    (21) point_expression -> POINT ( expression . , expression )
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    ,               shift and go to state 70
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 63

    (18) polygon_g -> POLYGON { ( points_expression ) . , color_expression }

    ,               shift and go to state 71


state 64

    (20) points_expression -> point_expression , . points_expression
    (19) points_expression -> . point_expression
    (20) points_expression -> . point_expression , points_expression
    (21) point_expression -> . POINT ( expression , expression )

    POINT           shift and go to state 39

    points_expression              shift and go to state 72
    point_expression               shift and go to state 55

state 65

    (11) translation -> TRANSLATE ( IDENTIFIER , point_expression . )

    )               shift and go to state 73


state 66

    (12) translation -> ROTATE ( IDENTIFIER , expression . )
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    )               shift and go to state 74
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 67

    (16) circle_g -> CIRCLE { point_expression , RADIUS . ( expression ) , color_expression }

    (               shift and go to state 75


state 68

    (17) rect_g -> RECT { point_expression , size_expression , . color_expression }
    (23) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 76

    color_expression               shift and go to state 77

state 69

    (22) size_expression -> SIZE ( . expression , expression )
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 78

state 70

    (21) point_expression -> POINT ( expression , . expression )
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 79

state 71

    (18) polygon_g -> POLYGON { ( points_expression ) , . color_expression }
    (23) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 76

    color_expression               shift and go to state 80

state 72

    (20) points_expression -> point_expression , points_expression .

    )               reduce using rule 20 (points_expression -> point_expression , points_expression .)


state 73

    (11) translation -> TRANSLATE ( IDENTIFIER , point_expression ) .

    ;               reduce using rule 11 (translation -> TRANSLATE ( IDENTIFIER , point_expression ) .)
    }               reduce using rule 11 (translation -> TRANSLATE ( IDENTIFIER , point_expression ) .)
    $end            reduce using rule 11 (translation -> TRANSLATE ( IDENTIFIER , point_expression ) .)


state 74

    (12) translation -> ROTATE ( IDENTIFIER , expression ) .

    ;               reduce using rule 12 (translation -> ROTATE ( IDENTIFIER , expression ) .)
    }               reduce using rule 12 (translation -> ROTATE ( IDENTIFIER , expression ) .)
    $end            reduce using rule 12 (translation -> ROTATE ( IDENTIFIER , expression ) .)


state 75

    (16) circle_g -> CIRCLE { point_expression , RADIUS ( . expression ) , color_expression }
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 81

state 76

    (23) color_expression -> COLOR . ( expression , expression , expression )

    (               shift and go to state 82


state 77

    (17) rect_g -> RECT { point_expression , size_expression , color_expression . }

    }               shift and go to state 83


state 78

    (22) size_expression -> SIZE ( expression . , expression )
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    ,               shift and go to state 84
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 79

    (21) point_expression -> POINT ( expression , expression . )
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    )               shift and go to state 85
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 80

    (18) polygon_g -> POLYGON { ( points_expression ) , color_expression . }

    }               shift and go to state 86


state 81

    (16) circle_g -> CIRCLE { point_expression , RADIUS ( expression . ) , color_expression }
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    )               shift and go to state 87
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 82

    (23) color_expression -> COLOR ( . expression , expression , expression )
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 88

state 83

    (17) rect_g -> RECT { point_expression , size_expression , color_expression } .

    ;               reduce using rule 17 (rect_g -> RECT { point_expression , size_expression , color_expression } .)
    $end            reduce using rule 17 (rect_g -> RECT { point_expression , size_expression , color_expression } .)
    }               reduce using rule 17 (rect_g -> RECT { point_expression , size_expression , color_expression } .)


state 84

    (22) size_expression -> SIZE ( expression , . expression )
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 89

state 85

    (21) point_expression -> POINT ( expression , expression ) .

    ,               reduce using rule 21 (point_expression -> POINT ( expression , expression ) .)
    )               reduce using rule 21 (point_expression -> POINT ( expression , expression ) .)


state 86

    (18) polygon_g -> POLYGON { ( points_expression ) , color_expression } .

    ;               reduce using rule 18 (polygon_g -> POLYGON { ( points_expression ) , color_expression } .)
    $end            reduce using rule 18 (polygon_g -> POLYGON { ( points_expression ) , color_expression } .)
    }               reduce using rule 18 (polygon_g -> POLYGON { ( points_expression ) , color_expression } .)


state 87

    (16) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) . , color_expression }

    ,               shift and go to state 90


state 88

    (23) color_expression -> COLOR ( expression . , expression , expression )
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    ,               shift and go to state 91
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 89

    (22) size_expression -> SIZE ( expression , expression . )
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    )               shift and go to state 92
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 90

    (16) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , . color_expression }
    (23) color_expression -> . COLOR ( expression , expression , expression )

    COLOR           shift and go to state 76

    color_expression               shift and go to state 93

state 91

    (23) color_expression -> COLOR ( expression , . expression , expression )
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 94

state 92

    (22) size_expression -> SIZE ( expression , expression ) .

    ,               reduce using rule 22 (size_expression -> SIZE ( expression , expression ) .)


state 93

    (16) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression . }

    }               shift and go to state 95


state 94

    (23) color_expression -> COLOR ( expression , expression . , expression )
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    ,               shift and go to state 96
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 95

    (16) circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .

    ;               reduce using rule 16 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)
    }               reduce using rule 16 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)
    $end            reduce using rule 16 (circle_g -> CIRCLE { point_expression , RADIUS ( expression ) , color_expression } .)


state 96

    (23) color_expression -> COLOR ( expression , expression , . expression )
    (24) expression -> . expression ADD_OP expression
    (25) expression -> . expression MUL_OP expression
    (26) expression -> . NUMBER
    (27) expression -> . IDENTIFIER
    (28) expression -> . ( expression )
    (29) expression -> . ADD_OP expression

    NUMBER          shift and go to state 20
    IDENTIFIER      shift and go to state 22
    (               shift and go to state 21
    ADD_OP          shift and go to state 24

    expression                     shift and go to state 97

state 97

    (23) color_expression -> COLOR ( expression , expression , expression . )
    (24) expression -> expression . ADD_OP expression
    (25) expression -> expression . MUL_OP expression

    )               shift and go to state 98
    ADD_OP          shift and go to state 35
    MUL_OP          shift and go to state 36


state 98

    (23) color_expression -> COLOR ( expression , expression , expression ) .

    }               reduce using rule 23 (color_expression -> COLOR ( expression , expression , expression ) .)

